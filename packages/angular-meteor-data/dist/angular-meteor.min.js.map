{"version":3,"sources":["webpack:///dist/angular-meteor.min.js","webpack:///webpack/bootstrap 08fc7e1c6e2df4ebc9d7","webpack:///./src/angular-meteor.js","webpack:///./src/lib/get-updates.js","webpack:///./src/lib/diff-array.js","webpack:///./src/modules/angular-meteor-ironrouter.js","webpack:///./src/modules/angular-meteor-utils.js","webpack:///./src/modules/angular-meteor-subscribe.js","webpack:///./src/modules/angular-meteor-collection.js","webpack:///./src/modules/angular-meteor-object.js","webpack:///./src/modules/angular-meteor-user.js","webpack:///./src/modules/angular-meteor-methods.js","webpack:///./src/modules/angular-meteor-session.js","webpack:///./src/modules/angular-meteor-camera.js","webpack:///./src/modules/utils.js","webpack:///./src/modules/mixer.js","webpack:///./src/modules/scope.js","webpack:///./src/modules/core.js","webpack:///./src/modules/view-model.js","webpack:///./src/modules/reactive.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Object","defineProperty","value","_module","angular","constant","suppressWarnings","run","$Mixer","$$Core","$$ViewModel","$$Reactive","mixin","service","$meteorCollection","$meteorCollectionFS","$meteorObject","$meteorMethods","$meteorSession","$meteorSubscribe","$meteorUtils","$meteorCamera","$meteorUser","_this","this","collection","collectionFS","object","subscribe","session","autorun","getCollectionByName","getPicture","forEach","method","console","log","loginWithPassword","utils","rip","obj","level","_","reduce","clone","v","k","isObject","toPaths","keys","getKeyPaths","values","getDeepValues","map","isEmpty","isArray","subKey","flatten","arr","push","setFilled","assert","result","msg","throwErr","Error","getDifference","src","dst","isShallow","compare","srcKeys","dstKeys","chain","concat","uniq","without","diff","srcValue","dstValue","isDate","getTime","valueDiff","getUpdates","paths","set","createSet","unset","createUnset","pull","createPull","updates","undefinedKeys","getUndefinedKeys","omit","pick","arrKeyPaths","split","match","compact","filter","isUndefined","factory","diffArray","lastSeqArray","seqArray","callbacks","preventNestedDiff","diffFn","Package","minimongo","LocalCollection","_diffQueryOrderedChanges","DiffSequence","diffQueryOrderedChanges","oldObjIds","newObjIds","posOld","posNew","posCur","lengthCur","length","each","doc","i","_id","idStringify","addedBefore","before","position","pos","addedAt","movedBefore","prevPosition","movedTo","removed","removedAt","idString","has","idParse","newItem","oldItem","changedAt","_idStringify","MongoID","_idParse","shallow","deepCopyChanges","setDiff","$set","deepKey","setDeep","deepCopyRemovals","unsetDiff","$unset","unsetDeep","getChanges","newCollection","oldCollection","diffMethod","changes","added","changed","item","index","selector","modifier","fromIndex","toIndex","initialKeys","initial","lastKey","last","subObj","nextKey","isNumStr","parseInt","isHash","deepObj","getDeep","splice","getPrototypeOf","prototype","str","$compile","$document","$rootScope","Router","isLoaded","onAfterAction","req","res","next","Tracker","afterFlush","$$phase","$apply","_typeof","Symbol","iterator","constructor","angularMeteorUtils","$q","$timeout","$angularMeteorSettings","self","scope","fn","warn","comp","firstRun","noop","$on","stop","stripDollarPrefixedKeys","data","Date","File","EJSON","toJSONValue","$type","FS","out","charAt","fulfill","deferred","boundError","boundResult","err","reject","resolve","promissor","defer","args","toArray","arguments","apply","promise","promiseAll","promises","allPromise","all","string","Mongo","Collection","get","findIndexById","foundDoc","find","colDoc","equals","indexOf","$meteorAutorun","angularMeteorSubscribe","_subscribe","subscription","lastArg","isFunction","onStop","_onStop","pop","onReady","$$state","status","Array","slice","Meteor","angularMeteorCollection","AngularMeteorCollection","curDefFunc","diffArrayFunc","autoClientSave","_serverBackup","_diffArrayFunc","_hObserve","_hNewCurAutorun","_hDataAutorun","isDefined","$$collection","cursor","name","extend","_startCurAutorun","onInvalidate","_stopCursor","_setAutoClientSave","_updateCursor","save","docs","useUnsetModifier","_upsertDoc","createFulfill","partial","docId","isExist","findOne","update","action","insert","_updateDiff","callback","setters","$pull","prop","puller","_updateParallel","done","after","affectedDocsNum","remove","keyOrDocs","keyOrDoc","pluck","check","Match","OneOf","String","ObjectID","key","_removeDoc","_stopObserving","observe","atIndex","_setServerUpdateMode","oldDoc","removedIndex","fetch","_serverMode","_unsetServerUpdateMode","_hUnsetTimeout","_unsetAutoClientSave","cancel","_saveChanges","_hRegAutoBind","$watch","nItems","oItems","addedDocs","reverse","descriptor","removedDocs","reactiveFunc","TypeError","bind","$meteorStopper","scopeProto","angularMeteorObject","AngularMeteorObject","options","helpers","_helpers","create","collectionExtension","$$options","$$id","_getId","$$internalProps","getRawObject","copy","custom","mods","when","reset","keepClientProps","clientProps","docKeys","docExtension","intersection","serverProps","removedKeys","difference","unregisterAutoDestroy","unregisterAutoBind","autorunComputation","fields","reactive","transform","isString","auto","_auto","_setAutos","angularMeteorUser","pack","Accounts","waitForUser","loggingIn","user","requireUser","requireValidUser","validatorFn","then","valid","createUser","changePassword","forgotPassword","resetPassword","verifyEmail","logout","logoutOtherClients","loginWithFacebook","loginWithTwitter","loginWithGoogle","loginWithGithub","loginWithMeteorDeveloperAccount","loginWithMeetup","loginWithWeibo","ScopeProto","currentUser","angularMeteorMethods","angularMeteorSession","$parse","model","getter","setter","assign","Session","angularMeteorCamera","MeteorCamera","isCursor","Cursor","isScope","areSiblings","obj1","obj2","context","tap","bindFn","bindObj","_len","_key","bound","_toConsumableArray","arr2","from","_mixins","union","_mixout","_construct","_extend","_ref","Scope","$new","isolate","parent","firstChild","$$ChildScope","__proto__","$$utils","undefined","$bindToContext","computation","$$autoStop","cb","_Meteor","ready","subscriptionId","callMethod","_Meteor2","applyMethod","_Meteor3","_len2","_key2","stoppable","$$throttledDigest","isDigestable","$$destroyed","$root","$digest","$$defer","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","enumerable","configurable","writable","protoProps","staticProps","vm","$$vm","viewModel","proto","boundProto","Reactive","_this2","_attached","_vm","$$dependencies","Dependency","$$setFnHelper","getReactively","isDeep","isBoolean","$$reactivateEntity","getCollectionReactively","$watchCollection","watcher","watcherArgs","$$watchEntity","depend","getVal","initialVal","val","oldVal","hasChanged","$$changed","_this3","nonreactive","observation","$$handleCursor","$$handleNonCursor","$$setValHelper","_this4","watch","newVal","_this5","jsondiffpatch","patch","$$depend"],"mappings":"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","file":"dist/angular-meteor.min.js","sourcesContent":["/*! angular-meteor v1.3.7-beta.1 */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(9);\n\t\n\t__webpack_require__(10);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(14);\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\t// new\n\t\n\t\n\tvar _module = 'angular-meteor';\n\t// legacy\n\t// lib\n\t\n\texports.default = _module;\n\t\n\t\n\tangular.module(_module, [\n\t// new\n\t'angular-meteor.utilities', 'angular-meteor.mixer', 'angular-meteor.scope', 'angular-meteor.core', 'angular-meteor.view-model', 'angular-meteor.reactive',\n\t\n\t// legacy\n\t'angular-meteor.ironrouter', 'angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'angular-meteor.object', 'angular-meteor.user', 'angular-meteor.methods', 'angular-meteor.session', 'angular-meteor.camera']).constant('$angularMeteorSettings', {\n\t  suppressWarnings: false\n\t}).run(['$Mixer', '$$Core', '$$ViewModel', '$$Reactive', function ($Mixer, $$Core, $$ViewModel, $$Reactive) {\n\t  // Load all mixins\n\t  $Mixer.mixin($$Core).mixin($$ViewModel).mixin($$Reactive);\n\t}])\n\t\n\t// legacy\n\t// Putting all services under $meteor service for syntactic sugar\n\t.service('$meteor', ['$meteorCollection', '$meteorCollectionFS', '$meteorObject', '$meteorMethods', '$meteorSession', '$meteorSubscribe', '$meteorUtils', '$meteorCamera', '$meteorUser', function ($meteorCollection, $meteorCollectionFS, $meteorObject, $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils, $meteorCamera, $meteorUser) {\n\t  var _this = this;\n\t\n\t  this.collection = $meteorCollection;\n\t  this.collectionFS = $meteorCollectionFS;\n\t  this.object = $meteorObject;\n\t  this.subscribe = $meteorSubscribe.subscribe;\n\t  this.call = $meteorMethods.call;\n\t  this.session = $meteorSession;\n\t  this.autorun = $meteorUtils.autorun;\n\t  this.getCollectionByName = $meteorUtils.getCollectionByName;\n\t  this.getPicture = $meteorCamera.getPicture;\n\t\n\t  // $meteorUser\n\t  ['loginWithPassword', 'requireUser', 'requireValidUser', 'waitForUser', 'createUser', 'changePassword', 'forgotPassword', 'resetPassword', 'verifyEmail', 'loginWithMeteorDeveloperAccount', 'loginWithFacebook', 'loginWithGithub', 'loginWithGoogle', 'loginWithMeetup', 'loginWithTwitter', 'loginWithWeibo', 'logout', 'logoutOtherClients'].forEach(function (method) {\n\t    _this[method] = $meteorUser[method];\n\t  });\n\t\n\t  console.log(this.loginWithPassword);\n\t}]);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _\r\n\t */\n\t\n\t'use strict';\n\t\n\t// https://github.com/DAB0mB/get-updates\n\t\n\t(function () {\n\t  var module = angular.module('getUpdates', []);\n\t\n\t  var utils = function () {\n\t    var rip = function rip(obj, level) {\n\t      if (level < 1) return {};\n\t\n\t      return _.reduce(obj, function (clone, v, k) {\n\t        v = _.isObject(v) ? rip(v, --level) : v;\n\t        clone[k] = v;\n\t        return clone;\n\t      }, {});\n\t    };\n\t\n\t    var toPaths = function toPaths(obj) {\n\t      var keys = getKeyPaths(obj);\n\t      var values = getDeepValues(obj);\n\t      return _.object(keys, values);\n\t    };\n\t\n\t    var getKeyPaths = function getKeyPaths(obj) {\n\t      var keys = _.keys(obj).map(function (k) {\n\t        var v = obj[k];\n\t        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\n\t\n\t        return getKeyPaths(v).map(function (subKey) {\n\t          return k + '.' + subKey;\n\t        });\n\t      });\n\t\n\t      return _.flatten(keys);\n\t    };\n\t\n\t    var getDeepValues = function getDeepValues(obj, arr) {\n\t      arr = arr || [];\n\t\n\t      _.values(obj).forEach(function (v) {\n\t        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) arr.push(v);else getDeepValues(v, arr);\n\t      });\n\t\n\t      return arr;\n\t    };\n\t\n\t    var flatten = function flatten(arr) {\n\t      return arr.reduce(function (flattened, v, i) {\n\t        if (_.isArray(v) && !_.isEmpty(v)) flattened.push.apply(flattened, flatten(v));else flattened.push(v);\n\t\n\t        return flattened;\n\t      }, []);\n\t    };\n\t\n\t    var setFilled = function setFilled(obj, k, v) {\n\t      if (!_.isEmpty(v)) obj[k] = v;\n\t    };\n\t\n\t    var assert = function assert(result, msg) {\n\t      if (!result) throwErr(msg);\n\t    };\n\t\n\t    var throwErr = function throwErr(msg) {\n\t      throw Error('get-updates error - ' + msg);\n\t    };\n\t\n\t    return {\n\t      rip: rip,\n\t      toPaths: toPaths,\n\t      getKeyPaths: getKeyPaths,\n\t      getDeepValues: getDeepValues,\n\t      setFilled: setFilled,\n\t      assert: assert,\n\t      throwErr: throwErr\n\t    };\n\t  }();\n\t\n\t  var getDifference = function () {\n\t    var getDifference = function getDifference(src, dst, isShallow) {\n\t      var level;\n\t\n\t      if (isShallow > 1) level = isShallow;else if (isShallow) level = 1;\n\t\n\t      if (level) {\n\t        src = utils.rip(src, level);\n\t        dst = utils.rip(dst, level);\n\t      }\n\t\n\t      return compare(src, dst);\n\t    };\n\t\n\t    var compare = function compare(src, dst) {\n\t      var srcKeys = _.keys(src);\n\t      var dstKeys = _.keys(dst);\n\t\n\t      var keys = _.chain([]).concat(srcKeys).concat(dstKeys).uniq().without('$$hashKey').value();\n\t\n\t      return keys.reduce(function (diff, k) {\n\t        var srcValue = src[k];\n\t        var dstValue = dst[k];\n\t\n\t        if (_.isDate(srcValue) && _.isDate(dstValue)) {\n\t          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n\t        }\n\t\n\t        if (_.isObject(srcValue) && _.isObject(dstValue)) {\n\t          var valueDiff = getDifference(srcValue, dstValue);\n\t          utils.setFilled(diff, k, valueDiff);\n\t        } else if (srcValue !== dstValue) {\n\t          diff[k] = dstValue;\n\t        }\n\t\n\t        return diff;\n\t      }, {});\n\t    };\n\t\n\t    return getDifference;\n\t  }();\n\t\n\t  var getUpdates = function () {\n\t    var getUpdates = function getUpdates(src, dst, isShallow) {\n\t      utils.assert(_.isObject(src), 'first argument must be an object');\n\t      utils.assert(_.isObject(dst), 'second argument must be an object');\n\t\n\t      var diff = getDifference(src, dst, isShallow);\n\t      var paths = utils.toPaths(diff);\n\t\n\t      var set = createSet(paths);\n\t      var unset = createUnset(paths);\n\t      var pull = createPull(unset);\n\t\n\t      var updates = {};\n\t      utils.setFilled(updates, '$set', set);\n\t      utils.setFilled(updates, '$unset', unset);\n\t      utils.setFilled(updates, '$pull', pull);\n\t\n\t      return updates;\n\t    };\n\t\n\t    var createSet = function createSet(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      return _.omit(paths, undefinedKeys);\n\t    };\n\t\n\t    var createUnset = function createUnset(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      var unset = _.pick(paths, undefinedKeys);\n\t\n\t      return _.reduce(unset, function (result, v, k) {\n\t        result[k] = true;\n\t        return result;\n\t      }, {});\n\t    };\n\t\n\t    var createPull = function createPull(unset) {\n\t      var arrKeyPaths = _.keys(unset).map(function (k) {\n\t        var split = k.match(/(.*)\\.\\d+$/);\n\t        return split && split[1];\n\t      });\n\t\n\t      return _.compact(arrKeyPaths).reduce(function (pull, k) {\n\t        pull[k] = null;\n\t        return pull;\n\t      }, {});\n\t    };\n\t\n\t    var getUndefinedKeys = function getUndefinedKeys(obj) {\n\t      return _.keys(obj).filter(function (k) {\n\t        var v = obj[k];\n\t        return _.isUndefined(v);\n\t      });\n\t    };\n\t\n\t    return getUpdates;\n\t  }();\n\t\n\t  module.value('getUpdates', getUpdates);\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Package\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar _module = angular.module('diffArray', ['getUpdates']);\n\t\n\t_module.factory('diffArray', ['getUpdates', function (getUpdates) {\n\t  var LocalCollection = Package.minimongo.LocalCollection;\n\t  var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n\t  var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\t\n\t  // Calculates the differences between `lastSeqArray` and\n\t  // `seqArray` and calls appropriate functions from `callbacks`.\n\t  // Reuses Minimongo's diff algorithm implementation.\n\t  // XXX Should be replaced with the original diffArray function here:\n\t  // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n\t  // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n\t  function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n\t    preventNestedDiff = !!preventNestedDiff;\n\t\n\t    var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges || Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\t\n\t    var oldObjIds = [];\n\t    var newObjIds = [];\n\t    var posOld = {}; // maps from idStringify'd ids\n\t    var posNew = {}; // ditto\n\t    var posCur = {};\n\t    var lengthCur = lastSeqArray.length;\n\t\n\t    _.each(seqArray, function (doc, i) {\n\t      newObjIds.push({ _id: doc._id });\n\t      posNew[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    _.each(lastSeqArray, function (doc, i) {\n\t      oldObjIds.push({ _id: doc._id });\n\t      posOld[idStringify(doc._id)] = i;\n\t      posCur[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    // Arrays can contain arbitrary objects. We don't diff the\n\t    // objects. Instead we always fire 'changedAt' callback on every\n\t    // object. The consumer of `observe-sequence` should deal with\n\t    // it appropriately.\n\t    diffFn(oldObjIds, newObjIds, {\n\t      addedBefore: function addedBefore(id, doc, before) {\n\t        var position = before ? posCur[idStringify(before)] : lengthCur;\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= position) posCur[id]++;\n\t        });\n\t\n\t        lengthCur++;\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.addedAt(id, seqArray[posNew[idStringify(id)]], position, before);\n\t      },\n\t\n\t      movedBefore: function movedBefore(id, before) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t        var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition && pos <= position) posCur[id]--;else if (pos <= prevPosition && pos >= position) posCur[id]++;\n\t        });\n\t\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.movedTo(id, seqArray[posNew[idStringify(id)]], prevPosition, position, before);\n\t      },\n\t      removed: function removed(id) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition) posCur[id]--;\n\t        });\n\t\n\t        delete posCur[idStringify(id)];\n\t        lengthCur--;\n\t\n\t        callbacks.removedAt(id, lastSeqArray[posOld[idStringify(id)]], prevPosition);\n\t      }\n\t    });\n\t\n\t    _.each(posNew, function (pos, idString) {\n\t      if (!_.has(posOld, idString)) return;\n\t\n\t      var id = idParse(idString);\n\t      var newItem = seqArray[pos] || {};\n\t      var oldItem = lastSeqArray[posOld[idString]];\n\t      var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n\t\n\t      if (!_.isEmpty(updates)) callbacks.changedAt(id, updates, pos, oldItem);\n\t    });\n\t  }\n\t\n\t  diffArray.shallow = function (lastSeqArray, seqArray, callbacks) {\n\t    return diffArray(lastSeqArray, seqArray, callbacks, true);\n\t  };\n\t\n\t  diffArray.deepCopyChanges = function (oldItem, newItem) {\n\t    var setDiff = getUpdates(oldItem, newItem).$set;\n\t\n\t    _.each(setDiff, function (v, deepKey) {\n\t      setDeep(oldItem, deepKey, v);\n\t    });\n\t  };\n\t\n\t  diffArray.deepCopyRemovals = function (oldItem, newItem) {\n\t    var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\t\n\t    _.each(unsetDiff, function (v, deepKey) {\n\t      unsetDeep(oldItem, deepKey);\n\t    });\n\t  };\n\t\n\t  // Finds changes between two collections\n\t  diffArray.getChanges = function (newCollection, oldCollection, diffMethod) {\n\t    var changes = { added: [], removed: [], changed: [] };\n\t\n\t    diffMethod(oldCollection, newCollection, {\n\t      addedAt: function addedAt(id, item, index) {\n\t        changes.added.push({ item: item, index: index });\n\t      },\n\t\n\t      removedAt: function removedAt(id, item, index) {\n\t        changes.removed.push({ item: item, index: index });\n\t      },\n\t\n\t      changedAt: function changedAt(id, updates, index, oldItem) {\n\t        changes.changed.push({ selector: id, modifier: updates });\n\t      },\n\t\n\t      movedTo: function movedTo(id, item, fromIndex, toIndex) {\n\t        // XXX do we need this?\n\t      }\n\t    });\n\t\n\t    return changes;\n\t  };\n\t\n\t  var setDeep = function setDeep(obj, deepKey, v) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _.initial(split);\n\t    var lastKey = _.last(split);\n\t\n\t    initialKeys.reduce(function (subObj, k, i) {\n\t      var nextKey = split[i + 1];\n\t\n\t      if (isNumStr(nextKey)) {\n\t        if (subObj[k] === null) subObj[k] = [];\n\t        if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n\t      } else if (subObj[k] === null || !isHash(subObj[k])) {\n\t        subObj[k] = {};\n\t      }\n\t\n\t      return subObj[k];\n\t    }, obj);\n\t\n\t    var deepObj = getDeep(obj, initialKeys);\n\t    deepObj[lastKey] = v;\n\t    return v;\n\t  };\n\t\n\t  var unsetDeep = function unsetDeep(obj, deepKey) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _.initial(split);\n\t    var lastKey = _.last(split);\n\t    var deepObj = getDeep(obj, initialKeys);\n\t\n\t    if (_.isArray(deepObj) && isNumStr(lastKey)) return !!deepObj.splice(lastKey, 1);else return delete deepObj[lastKey];\n\t  };\n\t\n\t  var getDeep = function getDeep(obj, keys) {\n\t    return keys.reduce(function (subObj, k) {\n\t      return subObj[k];\n\t    }, obj);\n\t  };\n\t\n\t  var isHash = function isHash(obj) {\n\t    return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n\t  };\n\t\n\t  var isNumStr = function isNumStr(str) {\n\t    return str.match(/^\\d+$/);\n\t  };\n\t\n\t  return diffArray;\n\t}]);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tangular.module('angular-meteor.ironrouter', []).run(['$compile', '$document', '$rootScope', function ($compile, $document, $rootScope) {\n\t  var Router = (Package['iron:router'] || {}).Router;\n\t  if (!Router) return;\n\t\n\t  var isLoaded = false;\n\t\n\t  // Recompile after iron:router builds page\n\t  Router.onAfterAction(function (req, res, next) {\n\t    Tracker.afterFlush(function () {\n\t      if (isLoaded) return;\n\t      $compile($document)($rootScope);\n\t      if (!$rootScope.$$phase) $rootScope.$apply();\n\t      isLoaded = true;\n\t    });\n\t  });\n\t}]);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Tracker, EJSON, FS, Mongo\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar angularMeteorUtils = angular.module('angular-meteor.utils', []);\n\t\n\tangularMeteorUtils.service('$meteorUtils', ['$q', '$timeout', '$angularMeteorSettings', function ($q, $timeout, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this.autorun = function (scope, fn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    // wrapping around Deps.autorun\n\t    var comp = Tracker.autorun(function (c) {\n\t      fn(c);\n\t      // this is run immediately for the first call\n\t      // but after that, we need to $apply to start Angular digest\n\t      if (!c.firstRun) $timeout(angular.noop, 0);\n\t    });\n\t\n\t    // stop autorun when scope is destroyed\n\t    scope.$on('$destroy', function () {\n\t      comp.stop();\n\t    });\n\t\n\t    // return autorun object so that it can be stopped manually\n\t    return comp;\n\t  };\n\t\n\t  // Borrowed from angularFire\n\t  // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n\t  this.stripDollarPrefixedKeys = function (data) {\n\t    if (!_.isObject(data) || data instanceof Date || data instanceof File || EJSON.toJSONValue(data).$type === 'oid' || (typeof FS === 'undefined' ? 'undefined' : _typeof(FS)) === 'object' && data instanceof FS.File) return data;\n\t\n\t    var out = _.isArray(data) ? [] : {};\n\t\n\t    _.each(data, function (v, k) {\n\t      if (typeof k !== 'string' || k.charAt(0) !== '$') out[k] = self.stripDollarPrefixedKeys(v);\n\t    });\n\t\n\t    return out;\n\t  };\n\t\n\t  // Returns a callback which fulfills promise\n\t  this.fulfill = function (deferred, boundError, boundResult) {\n\t    return function (err, result) {\n\t      if (err) deferred.reject(boundError === null ? err : boundError);else if (typeof boundResult == \"function\") deferred.resolve(boundResult === null ? result : boundResult(result));else deferred.resolve(boundResult === null ? result : boundResult);\n\t    };\n\t  };\n\t\n\t  // creates a function which invokes method with the given arguments and returns a promise\n\t  this.promissor = function (obj, method) {\n\t    return function () {\n\t      var deferred = $q.defer();\n\t      var fulfill = self.fulfill(deferred);\n\t      var args = _.toArray(arguments).concat(fulfill);\n\t      obj[method].apply(obj, args);\n\t      return deferred.promise;\n\t    };\n\t  };\n\t\n\t  // creates a $q.all() promise and call digestion loop on fulfillment\n\t  this.promiseAll = function (promises) {\n\t    var allPromise = $q.all(promises);\n\t\n\t    allPromise.finally(function () {\n\t      // calls digestion loop with no conflicts\n\t      $timeout(angular.noop);\n\t    });\n\t\n\t    return allPromise;\n\t  };\n\t\n\t  this.getCollectionByName = function (string) {\n\t    return Mongo.Collection.get(string);\n\t  };\n\t\n\t  this.findIndexById = function (collection, doc) {\n\t    var foundDoc = _.find(collection, function (colDoc) {\n\t      // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n\t      return EJSON.equals(colDoc._id, doc._id);\n\t    });\n\t\n\t    return _.indexOf(collection, foundDoc);\n\t  };\n\t}]);\n\t\n\tangularMeteorUtils.run(['$rootScope', '$meteorUtils', function ($rootScope, $meteorUtils) {\n\t  Object.getPrototypeOf($rootScope).$meteorAutorun = function (fn) {\n\t    return $meteorUtils.autorun(this, fn);\n\t  };\n\t}]);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, Meteor\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', []);\n\t\n\tangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings', function ($q, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this._subscribe = function (scope, deferred, args) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var subscription = null;\n\t    var lastArg = args[args.length - 1];\n\t\n\t    // User supplied onStop callback\n\t    // save it for later use and remove\n\t    // from subscription arguments\n\t    if (angular.isObject(lastArg) && angular.isFunction(lastArg.onStop)) {\n\t      var _onStop = lastArg.onStop;\n\t\n\t      args.pop();\n\t    }\n\t\n\t    args.push({\n\t      onReady: function onReady() {\n\t        deferred.resolve(subscription);\n\t      },\n\t      onStop: function onStop(err) {\n\t        if (!deferred.promise.$$state.status) {\n\t          if (err) deferred.reject(err);else deferred.reject(new Meteor.Error(\"Subscription Stopped\", \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n\t        } else if (_onStop)\n\t          // After promise was resolved or rejected\n\t          // call user supplied onStop callback.\n\t          _onStop.apply(this, Array.prototype.slice.call(arguments));\n\t      }\n\t    });\n\t\n\t    subscription = Meteor.subscribe.apply(scope, args);\n\t\n\t    return subscription;\n\t  };\n\t\n\t  this.subscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var subscription = null;\n\t\n\t    self._subscribe(this, deferred, args);\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\t\n\tangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe', function ($rootScope, $q, $meteorSubscribe) {\n\t  Object.getPrototypeOf($rootScope).$meteorSubscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\t\n\t    this.$on('$destroy', function () {\n\t      subscription.stop();\n\t    });\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Tracker, check, Match, Mongo\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorCollection = angular.module('angular-meteor.collection', ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray']);\n\t\n\t// The reason angular meteor collection is a factory function and not something\n\t// that inherit from array comes from here:\n\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n\t// We went with the direct extensions approach.\n\tangularMeteorCollection.factory('AngularMeteorCollection', ['$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\n\t\n\t  function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var data = [];\n\t    // Server backup data to evaluate what changes come from client\n\t    // after each server update.\n\t    data._serverBackup = [];\n\t    // Array differ function.\n\t    data._diffArrayFunc = diffArrayFunc;\n\t    // Handler of the cursor observer.\n\t    data._hObserve = null;\n\t    // On new cursor autorun handler\n\t    // (autorun for reactive variables).\n\t    data._hNewCurAutorun = null;\n\t    // On new data autorun handler\n\t    // (autorun for cursor.fetch).\n\t    data._hDataAutorun = null;\n\t\n\t    if (angular.isDefined(collection)) {\n\t      data.$$collection = collection;\n\t    } else {\n\t      var cursor = curDefFunc();\n\t      data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n\t    }\n\t\n\t    _.extend(data, AngularMeteorCollection);\n\t    data._startCurAutorun(curDefFunc, autoClientSave);\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorCollection._startCurAutorun = function (curDefFunc, autoClientSave) {\n\t    var self = this;\n\t\n\t    self._hNewCurAutorun = Tracker.autorun(function () {\n\t      // When the reactive func gets recomputated we need to stop any previous\n\t      // observeChanges.\n\t      Tracker.onInvalidate(function () {\n\t        self._stopCursor();\n\t      });\n\t\n\t      if (autoClientSave) self._setAutoClientSave();\n\t      self._updateCursor(curDefFunc(), autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorCollection.save = function (docs, useUnsetModifier) {\n\t    // save whole collection\n\t    if (!docs) docs = this;\n\t    // save single doc\n\t    docs = [].concat(docs);\n\t\n\t    var promises = docs.map(function (doc) {\n\t      return this._upsertDoc(doc, useUnsetModifier);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._upsertDoc = function (doc, useUnsetModifier) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\t\n\t    // delete $$hashkey\n\t    doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n\t    var docId = doc._id;\n\t    var isExist = collection.findOne(docId);\n\t\n\t    // update\n\t    if (isExist) {\n\t      // Deletes _id property (from the copy) so that\n\t      // it can be $set using update.\n\t      delete doc._id;\n\t      var modifier = useUnsetModifier ? { $unset: doc } : { $set: doc };\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      collection.update(docId, modifier, createFulfill(function () {\n\t        return { _id: docId, action: 'updated' };\n\t      }));\n\t    }\n\t    // insert\n\t    else {\n\t        collection.insert(doc, createFulfill(function (id) {\n\t          return { _id: id, action: 'inserted' };\n\t        }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  // performs $pull operations parallely.\n\t  // used for handling splice operations returned from getUpdates() to prevent conflicts.\n\t  // see issue: https://github.com/Urigo/angular-meteor/issues/793\n\t  AngularMeteorCollection._updateDiff = function (selector, update, callback) {\n\t    callback = callback || angular.noop;\n\t    var setters = _.omit(update, '$pull');\n\t    var updates = [setters];\n\t\n\t    _.each(update.$pull, function (pull, prop) {\n\t      var puller = {};\n\t      puller[prop] = pull;\n\t      updates.push({ $pull: puller });\n\t    });\n\t\n\t    this._updateParallel(selector, updates, callback);\n\t  };\n\t\n\t  // performs each update operation parallely\n\t  AngularMeteorCollection._updateParallel = function (selector, updates, callback) {\n\t    var self = this;\n\t    var done = _.after(updates.length, callback);\n\t\n\t    var next = function next(err, affectedDocsNum) {\n\t      if (err) return callback(err);\n\t      done(null, affectedDocsNum);\n\t    };\n\t\n\t    _.each(updates, function (update) {\n\t      self.$$collection.update(selector, update, next);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.remove = function (keyOrDocs) {\n\t    var keys;\n\t\n\t    // remove whole collection\n\t    if (!keyOrDocs) {\n\t      keys = _.pluck(this, '_id');\n\t    }\n\t    // remove docs\n\t    else {\n\t        keyOrDocs = [].concat(keyOrDocs);\n\t\n\t        keys = _.map(keyOrDocs, function (keyOrDoc) {\n\t          return keyOrDoc._id || keyOrDoc;\n\t        });\n\t      }\n\t\n\t    // Checks if all keys are correct.\n\t    check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\t\n\t    var promises = keys.map(function (key) {\n\t      return this._removeDoc(key);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._removeDoc = function (id) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n\t    collection.remove(id, fulfill);\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorCollection._updateCursor = function (cursor, autoClientSave) {\n\t    var self = this;\n\t    // XXX - consider adding an option for a non-orderd result for faster performance\n\t    if (self._hObserve) self._stopObserving();\n\t\n\t    self._hObserve = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        self.splice(atIndex, 0, doc);\n\t        self._serverBackup.splice(atIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        diffArray.deepCopyChanges(self[atIndex], doc);\n\t        diffArray.deepCopyRemovals(self[atIndex], doc);\n\t        self._serverBackup[atIndex] = self[atIndex];\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        self.splice(fromIndex, 1);\n\t        self.splice(toIndex, 0, doc);\n\t        self._serverBackup.splice(fromIndex, 1);\n\t        self._serverBackup.splice(toIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      removedAt: function removedAt(oldDoc) {\n\t        var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\n\t\n\t        if (removedIndex != -1) {\n\t          self.splice(removedIndex, 1);\n\t          self._serverBackup.splice(removedIndex, 1);\n\t          self._setServerUpdateMode();\n\t        } else {\n\t          // If it's been removed on client then it's already not in collection\n\t          // itself but still is in the _serverBackup.\n\t          removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\n\t\n\t          if (removedIndex != -1) {\n\t            self._serverBackup.splice(removedIndex, 1);\n\t          }\n\t        }\n\t      }\n\t    });\n\t\n\t    self._hDataAutorun = Tracker.autorun(function () {\n\t      cursor.fetch();\n\t      if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection._stopObserving = function () {\n\t    this._hObserve.stop();\n\t    this._hDataAutorun.stop();\n\t    delete this._serverMode;\n\t    delete this._hUnsetTimeout;\n\t  };\n\t\n\t  AngularMeteorCollection._setServerUpdateMode = function (name) {\n\t    this._serverMode = true;\n\t    // To simplify server update logic, we don't follow\n\t    // updates from the client at the same time.\n\t    this._unsetAutoClientSave();\n\t  };\n\t\n\t  // Here we use $timeout to combine multiple updates that go\n\t  // each one after another.\n\t  AngularMeteorCollection._unsetServerUpdateMode = function (autoClientSave) {\n\t    var self = this;\n\t\n\t    if (self._hUnsetTimeout) {\n\t      $timeout.cancel(self._hUnsetTimeout);\n\t      self._hUnsetTimeout = null;\n\t    }\n\t\n\t    self._hUnsetTimeout = $timeout(function () {\n\t      self._serverMode = false;\n\t      // Finds updates that was potentially done from the client side\n\t      // and saves them.\n\t      var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\n\t      self._saveChanges(changes);\n\t      // After, continues following client updates.\n\t      if (autoClientSave) self._setAutoClientSave();\n\t    }, 0);\n\t  };\n\t\n\t  AngularMeteorCollection.stop = function () {\n\t    this._stopCursor();\n\t    this._hNewCurAutorun.stop();\n\t  };\n\t\n\t  AngularMeteorCollection._stopCursor = function () {\n\t    this._unsetAutoClientSave();\n\t\n\t    if (this._hObserve) {\n\t      this._hObserve.stop();\n\t      this._hDataAutorun.stop();\n\t    }\n\t\n\t    this.splice(0);\n\t    this._serverBackup.splice(0);\n\t  };\n\t\n\t  AngularMeteorCollection._unsetAutoClientSave = function (name) {\n\t    if (this._hRegAutoBind) {\n\t      this._hRegAutoBind();\n\t      this._hRegAutoBind = null;\n\t    }\n\t  };\n\t\n\t  AngularMeteorCollection._setAutoClientSave = function () {\n\t    var self = this;\n\t\n\t    // Always unsets auto save to keep only one $watch handler.\n\t    self._unsetAutoClientSave();\n\t\n\t    self._hRegAutoBind = $rootScope.$watch(function () {\n\t      return self;\n\t    }, function (nItems, oItems) {\n\t      if (nItems === oItems) return;\n\t\n\t      var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\n\t      self._unsetAutoClientSave();\n\t      self._saveChanges(changes);\n\t      self._setAutoClientSave();\n\t    }, true);\n\t  };\n\t\n\t  AngularMeteorCollection._saveChanges = function (changes) {\n\t    var self = this;\n\t\n\t    // Saves added documents\n\t    // Using reversed iteration to prevent indexes from changing during splice\n\t    var addedDocs = changes.added.reverse().map(function (descriptor) {\n\t      self.splice(descriptor.index, 1);\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (addedDocs.length) self.save(addedDocs);\n\t\n\t    // Removes deleted documents\n\t    var removedDocs = changes.removed.map(function (descriptor) {\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (removedDocs.length) self.remove(removedDocs);\n\t\n\t    // Updates changed documents\n\t    changes.changed.forEach(function (descriptor) {\n\t      self._updateDiff(descriptor.selector, descriptor.modifier);\n\t    });\n\t  };\n\t\n\t  return AngularMeteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollectionFS', ['$meteorCollection', 'diffArray', '$angularMeteorSettings', function ($meteorCollection, diffArray, $angularMeteorSettings) {\n\t  function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n\t\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\n\t  }\n\t\n\t  return $meteorCollectionFS;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollection', ['AngularMeteorCollection', '$rootScope', 'diffArray', function (AngularMeteorCollection, $rootScope, diffArray) {\n\t  function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\n\t    // Validate parameters\n\t    if (!reactiveFunc) {\n\t      throw new TypeError('The first argument of $meteorCollection is undefined.');\n\t    }\n\t\n\t    if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n\t      throw new TypeError('The first argument of $meteorCollection must be a function or ' + 'a have a find function property.');\n\t    }\n\t\n\t    if (!angular.isFunction(reactiveFunc)) {\n\t      collection = angular.isDefined(collection) ? collection : reactiveFunc;\n\t      reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\n\t    }\n\t\n\t    // By default auto save - true.\n\t    autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n\t    diffFn = diffFn || diffArray;\n\t    return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\n\t  }\n\t\n\t  return $meteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.run(['$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper', function ($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n\t  scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n\t}]);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t  angular, _, Mongo\r\n\t*/\n\t\n\t'use strict';\n\t\n\tvar angularMeteorObject = angular.module('angular-meteor.object', ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray']);\n\t\n\tangularMeteorObject.factory('AngularMeteorObject', ['$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\n\t\n\t  // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n\t  AngularMeteorObject.$$internalProps = ['$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope', 'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject', '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'];\n\t\n\t  function AngularMeteorObject(collection, selector, options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    // Make data not be an object so we can extend it to preserve\n\t    // Collection Helpers and the like\n\t    var helpers = collection._helpers;\n\t    var data = _.isFunction(helpers) ? Object.create(helpers.prototype) : {};\n\t    var doc = collection.findOne(selector, options);\n\t    var collectionExtension = _.pick(AngularMeteorCollection, '_updateParallel');\n\t    _.extend(data, doc);\n\t    _.extend(data, AngularMeteorObject);\n\t    _.extend(data, collectionExtension);\n\t\n\t    // Omit options that may spoil document finding\n\t    data.$$options = _.omit(options, 'skip', 'limit');\n\t    data.$$collection = collection;\n\t    data.$$id = data._getId(selector);\n\t    data._serverBackup = doc || {};\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorObject.getRawObject = function () {\n\t    return angular.copy(_.omit(this, this.$$internalProps));\n\t  };\n\t\n\t  AngularMeteorObject.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorObject.save = function (custom) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\t    var oldDoc = collection.findOne(this.$$id);\n\t    var mods;\n\t\n\t    // update\n\t    if (oldDoc) {\n\t      if (custom) mods = { $set: custom };else {\n\t        mods = getUpdates(oldDoc, this.getRawObject());\n\t        // If there are no updates, there is nothing to do here, returning\n\t        if (_.isEmpty(mods)) {\n\t          return $q.when({ action: 'updated' });\n\t        }\n\t      }\n\t\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      this._updateDiff(mods, createFulfill({ action: 'updated' }));\n\t    }\n\t    // insert\n\t    else {\n\t        if (custom) mods = _.clone(custom);else mods = this.getRawObject();\n\t\n\t        mods._id = mods._id || this.$$id;\n\t        collection.insert(mods, createFulfill({ action: 'inserted' }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorObject._updateDiff = function (update, callback) {\n\t    var selector = this.$$id;\n\t    AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\n\t  };\n\t\n\t  AngularMeteorObject.reset = function (keepClientProps) {\n\t    var self = this;\n\t    var options = this.$$options;\n\t    var id = this.$$id;\n\t    var doc = this.$$collection.findOne(id, options);\n\t\n\t    if (doc) {\n\t      // extend SubObject\n\t      var docKeys = _.keys(doc);\n\t      var docExtension = _.pick(doc, docKeys);\n\t      var clientProps;\n\t\n\t      _.extend(self, docExtension);\n\t      _.extend(self._serverBackup, docExtension);\n\t\n\t      if (keepClientProps) {\n\t        clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\n\t      } else {\n\t        clientProps = _.keys(self);\n\t      }\n\t\n\t      var serverProps = _.keys(doc);\n\t      var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\n\t\n\t      removedKeys.forEach(function (prop) {\n\t        delete self[prop];\n\t        delete self._serverBackup[prop];\n\t      });\n\t    } else {\n\t      _.keys(this.getRawObject()).forEach(function (prop) {\n\t        delete self[prop];\n\t      });\n\t\n\t      self._serverBackup = {};\n\t    }\n\t  };\n\t\n\t  AngularMeteorObject.stop = function () {\n\t    if (this.unregisterAutoDestroy) this.unregisterAutoDestroy();\n\t\n\t    if (this.unregisterAutoBind) this.unregisterAutoBind();\n\t\n\t    if (this.autorunComputation && this.autorunComputation.stop) this.autorunComputation.stop();\n\t  };\n\t\n\t  AngularMeteorObject._getId = function (selector) {\n\t    var options = _.extend({}, this.$$options, {\n\t      fields: { _id: 1 },\n\t      reactive: false,\n\t      transform: null\n\t    });\n\t\n\t    var doc = this.$$collection.findOne(selector, options);\n\t\n\t    if (doc) return doc._id;\n\t    if (selector instanceof Mongo.ObjectID) return selector;\n\t    if (_.isString(selector)) return selector;\n\t    return new Mongo.ObjectID();\n\t  };\n\t\n\t  return AngularMeteorObject;\n\t}]);\n\t\n\tangularMeteorObject.factory('$meteorObject', ['$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject', function ($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n\t  function $meteorObject(collection, id, auto, options) {\n\t    // Validate parameters\n\t    if (!collection) {\n\t      throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n\t    }\n\t\n\t    if (!angular.isFunction(collection.findOne)) {\n\t      throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n\t    }\n\t\n\t    var data = new AngularMeteorObject(collection, id, options);\n\t    // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n\t    data._auto = auto !== false;\n\t    _.extend(data, $meteorObject);\n\t    data._setAutos();\n\t    return data;\n\t  }\n\t\n\t  $meteorObject._setAutos = function () {\n\t    var self = this;\n\t\n\t    this.autorunComputation = $meteorUtils.autorun($rootScope, function () {\n\t      self.reset(true);\n\t    });\n\t\n\t    // Deep watches the model and performs autobind\n\t    this.unregisterAutoBind = this._auto && $rootScope.$watch(function () {\n\t      return self.getRawObject();\n\t    }, function (item, oldItem) {\n\t      if (item !== oldItem) self.save();\n\t    }, true);\n\t\n\t    this.unregisterAutoDestroy = $rootScope.$on('$destroy', function () {\n\t      if (self && self.stop) self.pop();\n\t    });\n\t  };\n\t\n\t  return $meteorObject;\n\t}]);\n\t\n\tangularMeteorObject.run(['$rootScope', '$meteorObject', '$meteorStopper', function ($rootScope, $meteorObject, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorObject = $meteorStopper($meteorObject);\n\t}]);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Package, Meteor\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorUser = angular.module('angular-meteor.user', ['angular-meteor.utils', 'angular-meteor.core']);\n\t\n\t// requires package 'accounts-password'\n\tangularMeteorUser.service('$meteorUser', ['$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings', function ($rootScope, $meteorUtils, $q, $angularMeteorSettings) {\n\t\n\t  var pack = Package['accounts-base'];\n\t  if (!pack) return;\n\t\n\t  var self = this;\n\t  var Accounts = pack.Accounts;\n\t\n\t  this.waitForUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) deferred.resolve(Meteor.user());\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) {\n\t      console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    }\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) {\n\t        if (Meteor.user() === null) deferred.reject(\"AUTH_REQUIRED\");else deferred.resolve(Meteor.user());\n\t      }\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireValidUser = function (validatorFn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    return self.requireUser(true).then(function (user) {\n\t      var valid = validatorFn(user);\n\t\n\t      if (valid === true) return user;else if (typeof valid === \"string\") return $q.reject(valid);else return $q.reject(\"FORBIDDEN\");\n\t    });\n\t  };\n\t\n\t  this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n\t  this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n\t  this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n\t  this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n\t  this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n\t  this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n\t  this.logout = $meteorUtils.promissor(Meteor, 'logout');\n\t  this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n\t  this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n\t  this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n\t  this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n\t  this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n\t  this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n\t  this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n\t  this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n\t}]);\n\t\n\tangularMeteorUser.run(['$rootScope', '$angularMeteorSettings', '$$Core', function ($rootScope, $angularMeteorSettings, $$Core) {\n\t\n\t  var ScopeProto = Object.getPrototypeOf($rootScope);\n\t  _.extend(ScopeProto, $$Core);\n\t\n\t  $rootScope.autorun(function () {\n\t    if (!Meteor.user) return;\n\t    $rootScope.currentUser = Meteor.user();\n\t    $rootScope.loggingIn = Meteor.loggingIn();\n\t  });\n\t}]);\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Meteor\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils']);\n\t\n\tangularMeteorMethods.service('$meteorMethods', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  this.call = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t    var fulfill = $meteorUtils.fulfill(deferred);\n\t    var args = _.toArray(arguments).concat(fulfill);\n\t    Meteor.call.apply(this, args);\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, Session\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils']);\n\t\n\tangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings', function ($meteorUtils, $parse, $angularMeteorSettings) {\n\t  return function (session) {\n\t\n\t    return {\n\t\n\t      bind: function bind(scope, model) {\n\t        if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t        var getter = $parse(model);\n\t        var setter = getter.assign;\n\t        $meteorUtils.autorun(scope, function () {\n\t          setter(scope, Session.get(session));\n\t        });\n\t\n\t        scope.$watch(model, function (newItem, oldItem) {\n\t          Session.set(session, getter(scope));\n\t        }, true);\n\t      }\n\t    };\n\t  };\n\t}]);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, Package\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils']);\n\t\n\t// requires package 'mdg:camera'\n\tangularMeteorCamera.service('$meteorCamera', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t  var pack = Package['mdg:camera'];\n\t  if (!pack) return;\n\t\n\t  var MeteorCamera = pack.MeteorCamera;\n\t\n\t  this.getPicture = function (options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    options = options || {};\n\t    var deferred = $q.defer();\n\t    MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tangular.module('angular-meteor.utilities', [])\n\t\n\t/*\n\t  A utility service which is provided with general utility functions\n\t */\n\t.service('$$utils', ['$rootScope', function ($rootScope) {\n\t  var _this = this;\n\t\n\t  // Checks if an object is a cursor\n\t  this.isCursor = function (obj) {\n\t    return obj instanceof Meteor.Collection.Cursor;\n\t  };\n\t\n\t  // Cheecks if an object is a scope\n\t  this.isScope = function (obj) {\n\t    return obj instanceof $rootScope.constructor;\n\t  };\n\t\n\t  // Checks if two objects are siblings\n\t  this.areSiblings = function (obj1, obj2) {\n\t    return _.isObject(obj1) && _.isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t  };\n\t\n\t  // Binds function into a scpecified context. If an object is provided, will bind every\n\t  // value in the object which is a function. If a tap function is provided, it will be\n\t  // called right after the function has been invoked.\n\t  this.bind = function (fn, context, tap) {\n\t    tap = _.isFunction(tap) ? tap : angular.noop;\n\t    if (_.isFunction(fn)) return bindFn(fn, context, tap);\n\t    if (_.isObject(fn)) return bindObj(fn, context, tap);\n\t    return fn;\n\t  };\n\t\n\t  var bindFn = function bindFn(fn, context, tap) {\n\t    return function () {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      var result = fn.apply(context, args);\n\t      tap.call(context, {\n\t        result: result,\n\t        args: args\n\t      });\n\t      return result;\n\t    };\n\t  };\n\t\n\t  var bindObj = function bindObj(obj, context, tap) {\n\t    return _.keys(obj).reduce(function (bound, k) {\n\t      bound[k] = _this.bind(obj[k], context, tap);\n\t      return bound;\n\t    }, {});\n\t  };\n\t}]);\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tangular.module('angular-meteor.mixer', [])\n\t\n\t/*\n\t  A service which lets us apply mixins into the `ChildScope` prototype.\n\t  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n\t  and any time a `ChildScope` prototype is created\n\t  it will be extended by the `$Mixer`.\n\t  This concept is good because it keeps our code\n\t  clean and simple, and easy to extend.\n\t  So any time we would like to define a new behaviour to our scope,\n\t  we will just use the `$Mixer` service.\n\t */\n\t.service('$Mixer', function () {\n\t  var _this = this;\n\t\n\t  this._mixins = [];\n\t\n\t  // Adds a new mixin\n\t  this.mixin = function (mixin) {\n\t    if (!_.isObject(mixin)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    _this._mixins = _.union(_this._mixins, [mixin]);\n\t    return _this;\n\t  };\n\t\n\t  // Removes a mixin. Useful mainly for test purposes\n\t  this._mixout = function (mixin) {\n\t    _this._mixins = _.without(_this._mixins, mixin);\n\t    return _this;\n\t  };\n\t\n\t  // Invoke function mixins with the provided context and arguments\n\t  this._construct = function (context) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    _this._mixins.filter(_.isFunction).forEach(function (mixin) {\n\t      mixin.call.apply(mixin, [context].concat(args));\n\t    });\n\t\n\t    return context;\n\t  };\n\t\n\t  // Extend prototype with the defined mixins\n\t  this._extend = function (obj) {\n\t    var _ref;\n\t\n\t    return (_ref = _).extend.apply(_ref, [obj].concat(_toConsumableArray(_this._mixins)));\n\t  };\n\t});\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(13);\n\t\n\tangular.module('angular-meteor.scope', ['angular-meteor.mixer']).run(['$rootScope', '$Mixer', function ($rootScope, $Mixer) {\n\t  var Scope = $rootScope.constructor;\n\t  var $new = $rootScope.$new;\n\t\n\t  // Extends and constructs every newly created scope without affecting the root scope\n\t  Scope.prototype.$new = function (isolate, parent) {\n\t    var firstChild = this === $rootScope && !this.$$ChildScope;\n\t    var scope = $new.call(this, isolate, parent);\n\t\n\t    // If the scope is isolated we would like to extend it aswell\n\t    if (isolate) {\n\t      // The scope is the prototype of its upcomming child scopes, so the methods would\n\t      // be accessable to them as well\n\t      $Mixer._extend(scope);\n\t    }\n\t    // Else, if this is the first child of the root scope we would like to apply the extensions\n\t    // without affection the root scope\n\t    else if (firstChild) {\n\t        // Creating a middle layer where all the extensions are gonna be applied to\n\t        scope.__proto__ = this.$$ChildScope.prototype = $Mixer._extend(Object.create(this));\n\t      }\n\t\n\t    return $Mixer._construct(scope);\n\t  };\n\t}]);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tangular.module('angular-meteor.core', ['angular-meteor.utilities', 'angular-meteor.mixer'])\n\t\n\t/*\n\t  A mixin which provides us with core Meteor functions.\n\t */\n\t.factory('$$Core', ['$q', '$$utils', function ($q, $$utils) {\n\t  function $$Core() {}\n\t\n\t  // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n\t  $$Core.autorun = function (fn) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    fn = this.$bindToContext(fn);\n\t\n\t    if (!_.isFunction(fn)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t    if (!_.isObject(options)) {\n\t      throw Error('argument 2 must be an object');\n\t    }\n\t\n\t    var computation = Tracker.autorun(fn, options);\n\t    this.$$autoStop(computation);\n\t    return computation;\n\t  };\n\t\n\t  // Calls Meteor.subscribe() which will be digested after each invokation\n\t  // and automatically destroyed\n\t  $$Core.subscribe = function (name, fn, cb) {\n\t    fn = this.$bindToContext(fn || angular.noop);\n\t    cb = cb ? this.$bindToContext(cb) : angular.noop;\n\t\n\t    if (!_.isString(name)) {\n\t      throw Error('argument 1 must be a string');\n\t    }\n\t    if (!_.isFunction(fn)) {\n\t      throw Error('argument 2 must be a function');\n\t    }\n\t    if (!_.isFunction(cb) && !_.isObject(cb)) {\n\t      throw Error('argument 3 must be a function or an object');\n\t    }\n\t\n\t    var result = {};\n\t\n\t    var computation = this.autorun(function () {\n\t      var _Meteor;\n\t\n\t      var args = fn();\n\t      if (angular.isUndefined(args)) args = [];\n\t\n\t      if (!_.isArray(args)) {\n\t        throw Error('reactive function\\'s return value must be an array');\n\t      }\n\t\n\t      var subscription = (_Meteor = Meteor).subscribe.apply(_Meteor, [name].concat(_toConsumableArray(args), [cb]));\n\t      result.ready = subscription.ready.bind(subscription);\n\t      result.subscriptionId = subscription.subscriptionId;\n\t    });\n\t\n\t    // Once the computation has been stopped,\n\t    // any subscriptions made inside will be stopped as well\n\t    result.stop = computation.stop.bind(computation);\n\t    return result;\n\t  };\n\t\n\t  // Calls Meteor.call() wrapped by a digestion cycle\n\t  $$Core.callMethod = function () {\n\t    var _Meteor2;\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n\t    return (_Meteor2 = Meteor).call.apply(_Meteor2, args.concat([fn]));\n\t  };\n\t\n\t  // Calls Meteor.apply() wrapped by a digestion cycle\n\t  $$Core.applyMethod = function () {\n\t    var _Meteor3;\n\t\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n\t    return (_Meteor3 = Meteor).apply.apply(_Meteor3, args.concat([fn]));\n\t  };\n\t\n\t  $$Core.$$autoStop = function (stoppable) {\n\t    this.$on('$destroy', stoppable.stop.bind(stoppable));\n\t  };\n\t\n\t  // Digests scope only if there is no phase at the moment\n\t  $$Core.$$throttledDigest = function () {\n\t    var isDigestable = !this.$$destroyed && !this.$$phase && !this.$root.$$phase;\n\t\n\t    if (isDigestable) this.$digest();\n\t  };\n\t\n\t  // Creates a promise only that the digestion cycle will be called at its fulfillment\n\t  $$Core.$$defer = function () {\n\t    var deferred = $q.defer();\n\t    // Once promise has been fulfilled, digest\n\t    deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n\t    return deferred;\n\t  };\n\t\n\t  // Binds an object or a function to the scope to the view model and digest it once it is invoked\n\t  $$Core.$bindToContext = function (fn) {\n\t    return $$utils.bind(fn, this, this.$$throttledDigest.bind(this));\n\t  };\n\t\n\t  return $$Core;\n\t}]);\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(15);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tangular.module('angular-meteor.view-model', ['angular-meteor.utilities', 'angular-meteor.mixer', 'angular-meteor.core'])\n\t\n\t/*\n\t  A mixin which lets us bind a view model into a scope.\n\t  Note that only a single view model can be bound,\n\t  otherwise the scope might behave unexpectedly.\n\t  Mainly used to define the controller as the view model,\n\t  and very useful when wanting to use Angular's `controllerAs` syntax.\n\t */\n\t.factory('$$ViewModel', ['$$utils', '$Mixer', function ($$utils, $Mixer) {\n\t  function $$ViewModel() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // Defines the view model on the scope.\n\t    this.$$vm = vm;\n\t  }\n\t\n\t  // Gets an object, wraps it with scope functions and returns it\n\t  $$ViewModel.viewModel = function (vm) {\n\t    var _this = this;\n\t\n\t    if (!_.isObject(vm)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    // Apply mixin functions\n\t    $Mixer._mixins.forEach(function (mixin) {\n\t      // Reject methods which starts with double $\n\t      var keys = _.keys(mixin).filter(function (k) {\n\t        return k.match(/^(?!\\$\\$).*$/);\n\t      });\n\t      var proto = _.pick(mixin, keys);\n\t      // Bind all the methods to the prototype\n\t      var boundProto = $$utils.bind(proto, _this);\n\t      // Add the methods to the view model\n\t      _.extend(vm, boundProto);\n\t    });\n\t\n\t    // Apply mixin constructors on the view model\n\t    $Mixer._construct(this, vm);\n\t    return vm;\n\t  };\n\t\n\t  // Override $$Core.$bindToContext to be bound to view model instead of scope\n\t  $$ViewModel.$bindToContext = function (fn) {\n\t    return $$utils.bind(fn, this.$$vm, this.$$throttledDigest.bind(this));\n\t  };\n\t\n\t  return $$ViewModel;\n\t}])\n\t\n\t/*\n\t  Illustrates the old API where a view model is created using $reactive service\n\t */\n\t.service('$reactive', ['$$utils', function ($$utils) {\n\t  var Reactive = function () {\n\t    function Reactive(vm) {\n\t      var _this2 = this;\n\t\n\t      _classCallCheck(this, Reactive);\n\t\n\t      if (!_.isObject(vm)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\t\n\t      _.defer(function () {\n\t        if (!_this2._attached) {\n\t          console.warn('view model was not attached to any scope');\n\t        }\n\t      });\n\t\n\t      this._vm = vm;\n\t    }\n\t\n\t    _createClass(Reactive, [{\n\t      key: 'attach',\n\t      value: function attach(scope) {\n\t        this._attached = true;\n\t\n\t        if (!$$utils.isScope(scope)) {\n\t          throw Error('argument 1 must be a scope');\n\t        }\n\t\n\t        var viewModel = scope.viewModel(this._vm);\n\t\n\t        // Similar to the old/Meteor API\n\t        viewModel.call = viewModel.callMethod;\n\t        viewModel.apply = viewModel.applyMethod;\n\t\n\t        return viewModel;\n\t      }\n\t    }]);\n\t\n\t    return Reactive;\n\t  }();\n\t\n\t  return function (vm) {\n\t    return new Reactive(vm);\n\t  };\n\t}]);\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(16);\n\t\n\tangular.module('angular-meteor.reactive', ['angular-meteor.utilities', 'angular-meteor.mixer', 'angular-meteor.core', 'angular-meteor.view-model'])\n\t\n\t/*\n\t  A mixin which enhance our reactive abilities by providing methods that are capable of updating\n\t  our scope reactively.\n\t */\n\t.factory('$$Reactive', ['$parse', '$$utils', '$angularMeteorSettings', function ($parse, $$utils, $angularMeteorSettings) {\n\t  function $$Reactive() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // Helps us track changes made in the view model\n\t    vm.$$dependencies = {};\n\t  }\n\t\n\t  // Gets an object containing functions and define their results as reactive properties.\n\t  // Once a return value has been changed the property will be reset.\n\t  $$Reactive.helpers = function () {\n\t    var _this = this;\n\t\n\t    var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    if (!_.isObject(props)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    _.each(props, function (v, k, i) {\n\t      if (!_.isFunction(v)) {\n\t        throw Error('helper ' + (i + 1) + ' must be a function');\n\t      }\n\t\n\t      if (!_this.$$vm.$$dependencies[k]) {\n\t        // Registers a new dependency to the specified helper\n\t        _this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n\t      }\n\t\n\t      _this.$$setFnHelper(k, v);\n\t    });\n\t  };\n\t\n\t  // Gets a model reactively\n\t  $$Reactive.getReactively = function (k) {\n\t    var isDeep = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t    if (!_.isBoolean(isDeep)) {\n\t      throw Error('argument 2 must be a boolean');\n\t    }\n\t\n\t    return this.$$reactivateEntity(k, this.$watch, isDeep);\n\t  };\n\t\n\t  // Gets a collection reactively\n\t  $$Reactive.getCollectionReactively = function (k) {\n\t    return this.$$reactivateEntity(k, this.$watchCollection);\n\t  };\n\t\n\t  // Gets an entity reactively, and once it has been changed the computation will be recomputed\n\t  $$Reactive.$$reactivateEntity = function (k, watcher) {\n\t    if (!_.isString(k)) {\n\t      throw Error('argument 1 must be a string');\n\t    }\n\t\n\t    if (!this.$$vm.$$dependencies[k]) {\n\t      this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n\t\n\t      for (var _len = arguments.length, watcherArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t        watcherArgs[_key - 2] = arguments[_key];\n\t      }\n\t\n\t      this.$$watchEntity.apply(this, [k, watcher].concat(watcherArgs));\n\t    }\n\t\n\t    this.$$vm.$$dependencies[k].depend();\n\t    return $parse(k)(this.$$vm);\n\t  };\n\t\n\t  // Watches for changes in the view model, and if so will notify a change\n\t  $$Reactive.$$watchEntity = function (k, watcher) {\n\t    var _this2 = this;\n\t\n\t    // Gets a deep property from the view model\n\t    var getVal = _.partial($parse(k), this.$$vm);\n\t    var initialVal = getVal();\n\t\n\t    // Watches for changes in the view model\n\t\n\t    for (var _len2 = arguments.length, watcherArgs = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n\t      watcherArgs[_key2 - 2] = arguments[_key2];\n\t    }\n\t\n\t    watcher.call.apply(watcher, [this, getVal, function (val, oldVal) {\n\t      var hasChanged = val !== initialVal || val !== oldVal;\n\t\n\t      // Notify if a change has been detected\n\t      if (hasChanged) _this2.$$changed(k);\n\t    }].concat(watcherArgs));\n\t  };\n\t\n\t  // Invokes a function and sets the return value as a property\n\t  $$Reactive.$$setFnHelper = function (k, fn) {\n\t    var _this3 = this;\n\t\n\t    this.autorun(function (computation) {\n\t      // Invokes the reactive functon\n\t      var model = fn.apply(_this3.$$vm);\n\t\n\t      // Ignore notifications made by the following handler\n\t      Tracker.nonreactive(function () {\n\t        // If a cursor, observe its changes and update acoordingly\n\t        if ($$utils.isCursor(model)) {\n\t          (function () {\n\t            var observation = _this3.$$handleCursor(k, model);\n\t\n\t            computation.onInvalidate(function () {\n\t              observation.stop();\n\t              _this3.$$vm[k].splice(0);\n\t            });\n\t          })();\n\t        } else {\n\t          _this3.$$handleNonCursor(k, model);\n\t        }\n\t\n\t        // Notify change and update the view model\n\t        _this3.$$changed(k);\n\t      });\n\t    });\n\t  };\n\t\n\t  // Sets a value helper as a setter and a getter which will notify computations once used\n\t  $$Reactive.$$setValHelper = function (k, v) {\n\t    var _this4 = this;\n\t\n\t    var watch = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];\n\t\n\t    // If set, reactives property\n\t    if (watch) {\n\t      var isDeep = _.isObject(v);\n\t      this.getReactively(k, isDeep);\n\t    }\n\t\n\t    Object.defineProperty(this.$$vm, k, {\n\t      configurable: true,\n\t      enumerable: true,\n\t\n\t      get: function get() {\n\t        return v;\n\t      },\n\t      set: function set(newVal) {\n\t        v = newVal;\n\t        _this4.$$changed(k);\n\t      }\n\t    });\n\t  };\n\t\n\t  // Fetching a cursor and updates properties once the result set has been changed\n\t  $$Reactive.$$handleCursor = function (k, cursor) {\n\t    var _this5 = this;\n\t\n\t    // If not defined set it\n\t    if (angular.isUndefined(this.$$vm[k])) {\n\t      this.$$setValHelper(k, cursor.fetch(), false);\n\t    }\n\t    // If defined update it\n\t    else {\n\t        var diff = jsondiffpatch.diff(this.$$vm[k], cursor.fetch());\n\t        jsondiffpatch.patch(this.$$vm[k], diff);\n\t      }\n\t\n\t    // Observe changes made in the result set\n\t    var observation = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        if (!observation) return;\n\t        _this5.$$vm[k].splice(atIndex, 0, doc);\n\t        _this5.$$changed(k);\n\t      },\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        var diff = jsondiffpatch.diff(_this5.$$vm[k][atIndex], doc);\n\t        jsondiffpatch.patch(_this5.$$vm[k][atIndex], diff);\n\t        _this5.$$changed(k);\n\t      },\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        _this5.$$vm[k].splice(fromIndex, 1);\n\t        _this5.$$vm[k].splice(toIndex, 0, doc);\n\t        _this5.$$changed(k);\n\t      },\n\t      removedAt: function removedAt(oldDoc, atIndex) {\n\t        _this5.$$vm[k].splice(atIndex, 1);\n\t        _this5.$$changed(k);\n\t      }\n\t    });\n\t\n\t    return observation;\n\t  };\n\t\n\t  $$Reactive.$$handleNonCursor = function (k, data) {\n\t    var v = this.$$vm[k];\n\t\n\t    if (angular.isDefined(v)) {\n\t      delete this.$$vm[k];\n\t      v = null;\n\t    }\n\t\n\t    if (angular.isUndefined(v)) {\n\t      this.$$setValHelper(k, data);\n\t    }\n\t    // Update property if the new value is from the same type\n\t    else if ($$utils.areSiblings(v, data)) {\n\t        var diff = jsondiffpatch.diff(v, data);\n\t        jsondiffpatch.patch(v, diff);\n\t        this.$$changed(k);\n\t      } else {\n\t        this.$$vm[k] = data;\n\t      }\n\t  };\n\t\n\t  // Notifies dependency in view model\n\t  $$Reactive.$$depend = function (k) {\n\t    this.$$vm.$$dependencies[k].depend();\n\t  };\n\t\n\t  // Notifies change in view model\n\t  $$Reactive.$$changed = function (k) {\n\t    this.$$throttledDigest();\n\t    this.$$vm.$$dependencies[k].changed();\n\t  };\n\t\n\t  return $$Reactive;\n\t}]);\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-meteor.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 08fc7e1c6e2df4ebc9d7\n **/","// lib\nimport './lib/get-updates';\nimport './lib/diff-array';\n// legacy\nimport './modules/angular-meteor-ironrouter';\nimport './modules/angular-meteor-utils';\nimport './modules/angular-meteor-subscribe';\nimport './modules/angular-meteor-collection';\nimport './modules/angular-meteor-object';\nimport './modules/angular-meteor-user';\nimport './modules/angular-meteor-methods';\nimport './modules/angular-meteor-session';\nimport './modules/angular-meteor-camera';\n\n// new\nimport './modules/utils';\nimport './modules/mixer';\nimport './modules/scope';\nimport './modules/core';\nimport './modules/view-model';\nimport './modules/reactive';\n\nconst module = 'angular-meteor';\nexport default module;\n\nangular.module(module, [\n  // new\n  'angular-meteor.utilities',\n  'angular-meteor.mixer',\n  'angular-meteor.scope',\n  'angular-meteor.core',\n  'angular-meteor.view-model',\n  'angular-meteor.reactive',\n\n  // legacy\n  'angular-meteor.ironrouter',\n  'angular-meteor.utils',\n  'angular-meteor.subscribe',\n  'angular-meteor.collection',\n  'angular-meteor.object',\n  'angular-meteor.user',\n  'angular-meteor.methods',\n  'angular-meteor.session',\n  'angular-meteor.camera'\n\n])\n\n.constant('$angularMeteorSettings', {\n  suppressWarnings: false\n})\n\n.run([\n  '$Mixer',\n  '$$Core',\n  '$$ViewModel',\n  '$$Reactive',\n\n  function($Mixer, $$Core, $$ViewModel, $$Reactive) {\n    // Load all mixins\n    $Mixer\n      .mixin($$Core)\n      .mixin($$ViewModel)\n      .mixin($$Reactive);\n  }\n])\n\n// legacy\n// Putting all services under $meteor service for syntactic sugar\n.service('$meteor', [\n  '$meteorCollection',\n  '$meteorCollectionFS',\n  '$meteorObject',\n  '$meteorMethods',\n  '$meteorSession',\n  '$meteorSubscribe',\n  '$meteorUtils',\n  '$meteorCamera',\n  '$meteorUser',\n  function($meteorCollection, $meteorCollectionFS, $meteorObject,\n    $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils,\n    $meteorCamera, $meteorUser) {\n    this.collection = $meteorCollection;\n    this.collectionFS = $meteorCollectionFS;\n    this.object = $meteorObject;\n    this.subscribe = $meteorSubscribe.subscribe;\n    this.call = $meteorMethods.call;\n    this.session = $meteorSession;\n    this.autorun = $meteorUtils.autorun;\n    this.getCollectionByName = $meteorUtils.getCollectionByName;\n    this.getPicture = $meteorCamera.getPicture;\n\n    // $meteorUser\n    [\n      'loginWithPassword',\n      'requireUser',\n      'requireValidUser',\n      'waitForUser',\n      'createUser',\n      'changePassword',\n      'forgotPassword',\n      'resetPassword',\n      'verifyEmail',\n      'loginWithMeteorDeveloperAccount',\n      'loginWithFacebook',\n      'loginWithGithub',\n      'loginWithGoogle',\n      'loginWithMeetup',\n      'loginWithTwitter',\n      'loginWithWeibo',\n      'logout',\n      'logoutOtherClients'\n    ].forEach((method) => {\n      this[method] = $meteorUser[method];\n    });\n\n    console.log(this.loginWithPassword);\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/angular-meteor.js\n **/","/*global\r\n angular, _\r\n */\r\n\r\n'use strict';\r\n\r\n// https://github.com/DAB0mB/get-updates\r\n(function() {\r\n  var module = angular.module('getUpdates', []);\r\n\r\n  var utils = (function() {\r\n    var rip = function(obj, level) {\r\n      if (level < 1) return {};\r\n\r\n      return _.reduce(obj, function(clone, v, k) {\r\n        v = _.isObject(v) ? rip(v, --level) : v;\r\n        clone[k] = v;\r\n        return clone;\r\n      }, {});\r\n    };\r\n\r\n    var toPaths = function(obj) {\r\n      var keys = getKeyPaths(obj);\r\n      var values = getDeepValues(obj);\r\n      return _.object(keys, values);\r\n    };\r\n\r\n    var getKeyPaths = function(obj) {\r\n      var keys = _.keys(obj).map(function(k) {\r\n        var v = obj[k];\r\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\r\n\r\n        return getKeyPaths(v).map(function(subKey) {\r\n          return k + '.' + subKey;\r\n        });\r\n      });\r\n\r\n      return _.flatten(keys);\r\n    };\r\n\r\n    var getDeepValues = function(obj,arr) {\r\n      arr = arr || [];\r\n\r\n      _.values(obj).forEach(function(v) {\r\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v))\r\n          arr.push(v);\r\n        else\r\n          getDeepValues(v, arr);\r\n      });\r\n\r\n      return arr;\r\n    };\r\n\r\n    var flatten = function(arr) {\r\n      return arr.reduce(function(flattened, v, i) {\r\n        if (_.isArray(v) && !_.isEmpty(v))\r\n          flattened.push.apply(flattened, flatten(v));\r\n        else\r\n          flattened.push(v);\r\n\r\n        return flattened;\r\n      }, []);\r\n    };\r\n\r\n    var setFilled = function(obj, k, v) {\r\n      if (!_.isEmpty(v)) obj[k] = v;\r\n    };\r\n\r\n    var assert = function(result, msg) {\r\n      if (!result) throwErr(msg);\r\n    };\r\n\r\n    var throwErr = function(msg) {\r\n      throw Error('get-updates error - ' + msg);\r\n    };\r\n\r\n    return {\r\n      rip: rip,\r\n      toPaths: toPaths,\r\n      getKeyPaths: getKeyPaths,\r\n      getDeepValues: getDeepValues,\r\n      setFilled: setFilled,\r\n      assert: assert,\r\n      throwErr: throwErr\r\n    };\r\n  })();\r\n\r\n  var getDifference = (function() {\r\n    var getDifference = function(src, dst, isShallow) {\r\n      var level;\r\n\r\n      if (isShallow > 1)\r\n        level = isShallow;\r\n      else if (isShallow)\r\n        level = 1;\r\n\r\n      if (level) {\r\n        src = utils.rip(src, level);\r\n        dst = utils.rip(dst, level);\r\n      }\r\n\r\n      return compare(src, dst);\r\n    };\r\n\r\n    var compare = function(src, dst) {\r\n      var srcKeys = _.keys(src);\r\n      var dstKeys = _.keys(dst);\r\n\r\n      var keys = _.chain([])\r\n        .concat(srcKeys)\r\n        .concat(dstKeys)\r\n        .uniq()\r\n        .without('$$hashKey')\r\n        .value();\r\n\r\n      return keys.reduce(function(diff, k) {\r\n        var srcValue = src[k];\r\n        var dstValue = dst[k];\r\n\r\n        if (_.isDate(srcValue) && _.isDate(dstValue)) {\r\n          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\r\n        }\r\n\r\n        if (_.isObject(srcValue) && _.isObject(dstValue)) {\r\n          var valueDiff = getDifference(srcValue, dstValue);\r\n          utils.setFilled(diff, k, valueDiff);\r\n        }\r\n\r\n        else if (srcValue !== dstValue) {\r\n          diff[k] = dstValue;\r\n        }\r\n\r\n        return diff;\r\n      }, {});\r\n    };\r\n\r\n    return getDifference;\r\n  })();\r\n\r\n  var getUpdates = (function() {\r\n    var getUpdates = function(src, dst, isShallow) {\r\n      utils.assert(_.isObject(src), 'first argument must be an object');\r\n      utils.assert(_.isObject(dst), 'second argument must be an object');\r\n\r\n      var diff = getDifference(src, dst, isShallow);\r\n      var paths = utils.toPaths(diff);\r\n\r\n      var set = createSet(paths);\r\n      var unset = createUnset(paths);\r\n      var pull = createPull(unset);\r\n\r\n      var updates = {};\r\n      utils.setFilled(updates, '$set', set);\r\n      utils.setFilled(updates, '$unset', unset);\r\n      utils.setFilled(updates, '$pull', pull);\r\n\r\n      return updates;\r\n    };\r\n\r\n    var createSet = function(paths) {\r\n      var undefinedKeys = getUndefinedKeys(paths);\r\n      return _.omit(paths, undefinedKeys);\r\n    };\r\n\r\n    var createUnset = function(paths) {\r\n      var undefinedKeys = getUndefinedKeys(paths);\r\n      var unset = _.pick(paths, undefinedKeys);\r\n\r\n      return _.reduce(unset, function(result, v, k) {\r\n        result[k] = true;\r\n        return result;\r\n      }, {});\r\n    };\r\n\r\n    var createPull = function(unset) {\r\n      var arrKeyPaths = _.keys(unset).map(function(k) {\r\n        var split = k.match(/(.*)\\.\\d+$/);\r\n        return split && split[1];\r\n      });\r\n\r\n      return _.compact(arrKeyPaths).reduce(function(pull, k) {\r\n        pull[k] = null;\r\n        return pull;\r\n      }, {});\r\n    };\r\n\r\n    var getUndefinedKeys = function(obj) {\r\n      return _.keys(obj).filter(function (k) {\r\n        var v = obj[k];\r\n        return _.isUndefined(v);\r\n      });\r\n    };\r\n\r\n    return getUpdates;\r\n  })();\r\n\r\n  module.value('getUpdates', getUpdates);\r\n})();\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/get-updates.js\n **/","/*global\r\n angular, _, Package\r\n */\r\n\r\n'use strict';\r\n\r\nvar _module = angular.module('diffArray', ['getUpdates']);\r\n\r\n_module.factory('diffArray', ['getUpdates',\r\n  function(getUpdates) {\r\n    var LocalCollection = Package.minimongo.LocalCollection;\r\n    var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\r\n    var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\r\n\r\n    // Calculates the differences between `lastSeqArray` and\r\n    // `seqArray` and calls appropriate functions from `callbacks`.\r\n    // Reuses Minimongo's diff algorithm implementation.\r\n    // XXX Should be replaced with the original diffArray function here:\r\n    // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\r\n    // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\r\n    function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\r\n      preventNestedDiff = !!preventNestedDiff;\r\n\r\n      var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges ||\r\n        Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\r\n\r\n      var oldObjIds = [];\r\n      var newObjIds = [];\r\n      var posOld = {}; // maps from idStringify'd ids\r\n      var posNew = {}; // ditto\r\n      var posCur = {};\r\n      var lengthCur = lastSeqArray.length;\r\n\r\n      _.each(seqArray, function (doc, i) {\r\n        newObjIds.push({_id: doc._id});\r\n        posNew[idStringify(doc._id)] = i;\r\n      });\r\n\r\n      _.each(lastSeqArray, function (doc, i) {\r\n        oldObjIds.push({_id: doc._id});\r\n        posOld[idStringify(doc._id)] = i;\r\n        posCur[idStringify(doc._id)] = i;\r\n      });\r\n\r\n      // Arrays can contain arbitrary objects. We don't diff the\r\n      // objects. Instead we always fire 'changedAt' callback on every\r\n      // object. The consumer of `observe-sequence` should deal with\r\n      // it appropriately.\r\n      diffFn(oldObjIds, newObjIds, {\r\n        addedBefore: function (id, doc, before) {\r\n          var position = before ? posCur[idStringify(before)] : lengthCur;\r\n\r\n          _.each(posCur, function (pos, id) {\r\n            if (pos >= position) posCur[id]++;\r\n          });\r\n\r\n          lengthCur++;\r\n          posCur[idStringify(id)] = position;\r\n\r\n          callbacks.addedAt(\r\n            id,\r\n            seqArray[posNew[idStringify(id)]],\r\n            position,\r\n            before\r\n          );\r\n        },\r\n\r\n        movedBefore: function (id, before) {\r\n          var prevPosition = posCur[idStringify(id)];\r\n          var position = before ? posCur[idStringify(before)] : lengthCur - 1;\r\n\r\n          _.each(posCur, function (pos, id) {\r\n            if (pos >= prevPosition && pos <= position)\r\n              posCur[id]--;\r\n            else if (pos <= prevPosition && pos >= position)\r\n              posCur[id]++;\r\n          });\r\n\r\n          posCur[idStringify(id)] = position;\r\n\r\n          callbacks.movedTo(\r\n            id,\r\n            seqArray[posNew[idStringify(id)]],\r\n            prevPosition,\r\n            position,\r\n            before\r\n          );\r\n        },\r\n        removed: function (id) {\r\n          var prevPosition = posCur[idStringify(id)];\r\n\r\n          _.each(posCur, function (pos, id) {\r\n            if (pos >= prevPosition) posCur[id]--;\r\n          });\r\n\r\n          delete posCur[idStringify(id)];\r\n          lengthCur--;\r\n\r\n          callbacks.removedAt(\r\n            id,\r\n            lastSeqArray[posOld[idStringify(id)]],\r\n            prevPosition\r\n          );\r\n        }\r\n      });\r\n\r\n      _.each(posNew, function (pos, idString) {\r\n        if (!_.has(posOld, idString)) return;\r\n\r\n        var id = idParse(idString);\r\n        var newItem = seqArray[pos] || {};\r\n        var oldItem = lastSeqArray[posOld[idString]];\r\n        var updates = getUpdates(oldItem, newItem, preventNestedDiff);\r\n\r\n        if (!_.isEmpty(updates))\r\n          callbacks.changedAt(id, updates, pos, oldItem);\r\n      });\r\n    }\r\n\r\n    diffArray.shallow = function(lastSeqArray, seqArray, callbacks) {\r\n      return diffArray(lastSeqArray, seqArray, callbacks, true);\r\n    };\r\n\r\n    diffArray.deepCopyChanges = function (oldItem, newItem) {\r\n      var setDiff = getUpdates(oldItem, newItem).$set;\r\n\r\n      _.each(setDiff, function(v, deepKey) {\r\n        setDeep(oldItem, deepKey, v);\r\n      });\r\n    };\r\n\r\n    diffArray.deepCopyRemovals = function (oldItem, newItem) {\r\n      var unsetDiff = getUpdates(oldItem, newItem).$unset;\r\n\r\n      _.each(unsetDiff, function(v, deepKey) {\r\n        unsetDeep(oldItem, deepKey);\r\n      });\r\n    };\r\n\r\n    // Finds changes between two collections\r\n    diffArray.getChanges = function(newCollection, oldCollection, diffMethod) {\r\n      var changes = {added: [], removed: [], changed: []};\r\n\r\n      diffMethod(oldCollection, newCollection, {\r\n        addedAt: function(id, item, index) {\r\n          changes.added.push({item: item, index: index});\r\n        },\r\n\r\n        removedAt: function(id, item, index) {\r\n          changes.removed.push({item: item, index: index});\r\n        },\r\n\r\n        changedAt: function(id, updates, index, oldItem) {\r\n          changes.changed.push({selector: id, modifier: updates});\r\n        },\r\n\r\n        movedTo: function(id, item, fromIndex, toIndex) {\r\n          // XXX do we need this?\r\n        }\r\n      });\r\n\r\n      return changes;\r\n    };\r\n\r\n    var setDeep = function(obj, deepKey, v) {\r\n      var split = deepKey.split('.');\r\n      var initialKeys = _.initial(split);\r\n      var lastKey = _.last(split);\r\n\r\n      initialKeys.reduce(function(subObj, k, i) {\r\n        var nextKey = split[i + 1];\r\n\r\n        if (isNumStr(nextKey)) {\r\n          if (subObj[k] === null) subObj[k] = [];\r\n          if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\r\n        }\r\n\r\n        else if (subObj[k] === null || !isHash(subObj[k])) {\r\n          subObj[k] = {};\r\n        }\r\n\r\n        return subObj[k];\r\n      }, obj);\r\n\r\n      var deepObj = getDeep(obj, initialKeys);\r\n      deepObj[lastKey] = v;\r\n      return v;\r\n    };\r\n\r\n    var unsetDeep = function(obj, deepKey) {\r\n      var split = deepKey.split('.');\r\n      var initialKeys = _.initial(split);\r\n      var lastKey = _.last(split);\r\n      var deepObj = getDeep(obj, initialKeys);\r\n\r\n      if (_.isArray(deepObj) && isNumStr(lastKey))\r\n        return !!deepObj.splice(lastKey, 1);\r\n      else\r\n        return delete deepObj[lastKey];\r\n    };\r\n\r\n    var getDeep = function(obj, keys) {\r\n      return keys.reduce(function(subObj, k) {\r\n        return subObj[k];\r\n      }, obj);\r\n    };\r\n\r\n    var isHash = function(obj) {\r\n      return _.isObject(obj) &&\r\n             Object.getPrototypeOf(obj) === Object.prototype;\r\n    };\r\n\r\n    var isNumStr = function(str) {\r\n      return str.match(/^\\d+$/);\r\n    };\r\n\r\n    return diffArray;\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/diff-array.js\n **/","angular.module('angular-meteor.ironrouter', [])\r\n\r\n\r\n.run([\r\n  '$compile',\r\n  '$document',\r\n  '$rootScope',\r\n\r\nfunction ($compile, $document, $rootScope) {\r\n  const Router = (Package['iron:router'] || {}).Router;\r\n  if (!Router) return;\r\n\r\n  let isLoaded = false;\r\n\r\n  // Recompile after iron:router builds page\r\n  Router.onAfterAction((req, res, next) => {\r\n    Tracker.afterFlush(() => {\r\n      if (isLoaded) return;\r\n      $compile($document)($rootScope);\r\n      if (!$rootScope.$$phase) $rootScope.$apply();\r\n      isLoaded = true;\r\n    });\r\n  });\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-ironrouter.js\n **/","/*global\r\n angular, _, Tracker, EJSON, FS, Mongo\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorUtils = angular.module('angular-meteor.utils', []);\r\n\r\nangularMeteorUtils.service('$meteorUtils', [\r\n  '$q', '$timeout', '$angularMeteorSettings',\r\n  function ($q, $timeout, $angularMeteorSettings) {\r\n\r\n    var self = this;\r\n\r\n    this.autorun = function(scope, fn) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n\r\n      // wrapping around Deps.autorun\r\n      var comp = Tracker.autorun(function(c) {\r\n        fn(c);\r\n        // this is run immediately for the first call\r\n        // but after that, we need to $apply to start Angular digest\r\n        if (!c.firstRun) $timeout(angular.noop, 0);\r\n      });\r\n\r\n      // stop autorun when scope is destroyed\r\n      scope.$on('$destroy', function() {\r\n        comp.stop();\r\n      });\r\n\r\n      // return autorun object so that it can be stopped manually\r\n      return comp;\r\n    };\r\n\r\n    // Borrowed from angularFire\r\n    // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\r\n    this.stripDollarPrefixedKeys = function (data) {\r\n      if (!_.isObject(data) ||\r\n          data instanceof Date ||\r\n          data instanceof File ||\r\n          EJSON.toJSONValue(data).$type === 'oid' ||\r\n          (typeof FS === 'object' && data instanceof FS.File))\r\n        return data;\r\n\r\n      var out = _.isArray(data) ? [] : {};\r\n\r\n      _.each(data, function(v,k) {\r\n        if(typeof k !== 'string' || k.charAt(0) !== '$')\r\n          out[k] = self.stripDollarPrefixedKeys(v);\r\n      });\r\n\r\n      return out;\r\n    };\r\n\r\n    // Returns a callback which fulfills promise\r\n    this.fulfill = function(deferred, boundError, boundResult) {\r\n      return function(err, result) {\r\n        if (err)\r\n          deferred.reject(boundError === null ? err : boundError);\r\n        else if (typeof boundResult == \"function\")\r\n          deferred.resolve(boundResult === null ? result : boundResult(result));\r\n        else\r\n          deferred.resolve(boundResult === null ? result : boundResult);\r\n      };\r\n    };\r\n\r\n    // creates a function which invokes method with the given arguments and returns a promise\r\n    this.promissor = function(obj, method) {\r\n      return function() {\r\n        var deferred = $q.defer();\r\n        var fulfill = self.fulfill(deferred);\r\n        var args = _.toArray(arguments).concat(fulfill);\r\n        obj[method].apply(obj, args);\r\n        return deferred.promise;\r\n      };\r\n    };\r\n\r\n    // creates a $q.all() promise and call digestion loop on fulfillment\r\n    this.promiseAll = function(promises) {\r\n      var allPromise = $q.all(promises);\r\n\r\n      allPromise.finally(function() {\r\n        // calls digestion loop with no conflicts\r\n        $timeout(angular.noop);\r\n      });\r\n\r\n      return allPromise;\r\n    };\r\n\r\n    this.getCollectionByName = function(string){\r\n      return Mongo.Collection.get(string);\r\n    };\r\n\r\n    this.findIndexById = function(collection, doc) {\r\n      var foundDoc = _.find(collection, function(colDoc) {\r\n        // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\r\n        return EJSON.equals(colDoc._id, doc._id);\r\n      });\r\n\r\n      return _.indexOf(collection, foundDoc);\r\n    };\r\n  }\r\n]);\r\n\r\nangularMeteorUtils.run([\r\n  '$rootScope', '$meteorUtils',\r\n  function($rootScope, $meteorUtils) {\r\n    Object.getPrototypeOf($rootScope).$meteorAutorun = function(fn) {\r\n      return $meteorUtils.autorun(this, fn);\r\n    };\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-utils.js\n **/","/*global\r\n angular, Meteor\r\n */\r\n\r\n'use strict';\r\nvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', []);\r\n\r\nangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings',\r\n  function ($q, $angularMeteorSettings) {\r\n\r\n    var self = this;\r\n\r\n    this._subscribe = function(scope, deferred, args) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var subscription = null;\r\n      var lastArg = args[args.length - 1];\r\n\r\n      // User supplied onStop callback\r\n      // save it for later use and remove\r\n      // from subscription arguments\r\n      if (angular.isObject(lastArg) &&\r\n          angular.isFunction(lastArg.onStop)) {\r\n        var onStop = lastArg.onStop;\r\n\r\n        args.pop();\r\n      }\r\n\r\n      args.push({\r\n        onReady: function() {\r\n          deferred.resolve(subscription);\r\n        },\r\n        onStop: function(err) {\r\n          if (!deferred.promise.$$state.status) {\r\n            if (err)\r\n              deferred.reject(err);\r\n            else\r\n              deferred.reject(new Meteor.Error(\"Subscription Stopped\",\r\n                \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\r\n          } else if (onStop)\r\n            // After promise was resolved or rejected\r\n            // call user supplied onStop callback.\r\n            onStop.apply(this, Array.prototype.slice.call(arguments));\r\n\r\n        }\r\n      });\r\n\r\n      subscription =  Meteor.subscribe.apply(scope, args);\r\n\r\n      return subscription;\r\n    };\r\n\r\n    this.subscribe = function(){\r\n      var deferred = $q.defer();\r\n      var args = Array.prototype.slice.call(arguments);\r\n      var subscription = null;\r\n\r\n      self._subscribe(this, deferred, args);\r\n\r\n      return deferred.promise;\r\n    };\r\n  }]);\r\n\r\nangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe',\r\n  function($rootScope, $q, $meteorSubscribe) {\r\n    Object.getPrototypeOf($rootScope).$meteorSubscribe = function() {\r\n      var deferred = $q.defer();\r\n      var args = Array.prototype.slice.call(arguments);\r\n\r\n      var subscription = $meteorSubscribe._subscribe(this, deferred, args);\r\n\r\n      this.$on('$destroy', function() {\r\n        subscription.stop();\r\n      });\r\n\r\n      return deferred.promise;\r\n    };\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-subscribe.js\n **/","/*global\r\n angular, _, Tracker, check, Match, Mongo\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorCollection = angular.module('angular-meteor.collection',\r\n  ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray']);\r\n\r\n// The reason angular meteor collection is a factory function and not something\r\n// that inherit from array comes from here:\r\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\r\n// We went with the direct extensions approach.\r\nangularMeteorCollection.factory('AngularMeteorCollection', [\r\n  '$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings',\r\n  function($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\r\n\r\n    function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var data = [];\r\n      // Server backup data to evaluate what changes come from client\r\n      // after each server update.\r\n      data._serverBackup = [];\r\n      // Array differ function.\r\n      data._diffArrayFunc = diffArrayFunc;\r\n      // Handler of the cursor observer.\r\n      data._hObserve = null;\r\n      // On new cursor autorun handler\r\n      // (autorun for reactive variables).\r\n      data._hNewCurAutorun = null;\r\n      // On new data autorun handler\r\n      // (autorun for cursor.fetch).\r\n      data._hDataAutorun = null;\r\n\r\n      if (angular.isDefined(collection)) {\r\n        data.$$collection = collection;\r\n      } else {\r\n        var cursor = curDefFunc();\r\n        data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\r\n      }\r\n\r\n      _.extend(data, AngularMeteorCollection);\r\n      data._startCurAutorun(curDefFunc, autoClientSave);\r\n\r\n      return data;\r\n    }\r\n\r\n    AngularMeteorCollection._startCurAutorun = function(curDefFunc, autoClientSave) {\r\n      var self = this;\r\n\r\n      self._hNewCurAutorun = Tracker.autorun(function() {\r\n        // When the reactive func gets recomputated we need to stop any previous\r\n        // observeChanges.\r\n        Tracker.onInvalidate(function() {\r\n          self._stopCursor();\r\n        });\r\n\r\n        if (autoClientSave) self._setAutoClientSave();\r\n        self._updateCursor(curDefFunc(), autoClientSave);\r\n      });\r\n    };\r\n\r\n    AngularMeteorCollection.subscribe = function() {\r\n      $meteorSubscribe.subscribe.apply(this, arguments);\r\n      return this;\r\n    };\r\n\r\n    AngularMeteorCollection.save = function(docs, useUnsetModifier) {\r\n      // save whole collection\r\n      if (!docs) docs = this;\r\n      // save single doc\r\n      docs = [].concat(docs);\r\n\r\n      var promises = docs.map(function(doc) {\r\n        return this._upsertDoc(doc, useUnsetModifier);\r\n      }, this);\r\n\r\n      return $meteorUtils.promiseAll(promises);\r\n    };\r\n\r\n    AngularMeteorCollection._upsertDoc = function(doc, useUnsetModifier) {\r\n      var deferred = $q.defer();\r\n      var collection = this.$$collection;\r\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\r\n\r\n      // delete $$hashkey\r\n      doc = $meteorUtils.stripDollarPrefixedKeys(doc);\r\n      var docId = doc._id;\r\n      var isExist = collection.findOne(docId);\r\n\r\n      // update\r\n      if (isExist) {\r\n        // Deletes _id property (from the copy) so that\r\n        // it can be $set using update.\r\n        delete doc._id;\r\n        var modifier = useUnsetModifier ? {$unset: doc} : {$set: doc};\r\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\r\n        collection.update(docId, modifier, createFulfill(function() {\r\n          return {_id: docId, action: 'updated'};\r\n        }));\r\n      }\r\n      // insert\r\n      else {\r\n        collection.insert(doc, createFulfill(function(id) {\r\n          return {_id: id, action: 'inserted'};\r\n        }));\r\n      }\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    // performs $pull operations parallely.\r\n    // used for handling splice operations returned from getUpdates() to prevent conflicts.\r\n    // see issue: https://github.com/Urigo/angular-meteor/issues/793\r\n    AngularMeteorCollection._updateDiff = function(selector, update, callback) {\r\n      callback = callback || angular.noop;\r\n      var setters = _.omit(update, '$pull');\r\n      var updates = [setters];\r\n\r\n      _.each(update.$pull, function(pull, prop) {\r\n        var puller = {};\r\n        puller[prop] = pull;\r\n        updates.push({ $pull: puller });\r\n      });\r\n\r\n      this._updateParallel(selector, updates, callback);\r\n    };\r\n\r\n    // performs each update operation parallely\r\n    AngularMeteorCollection._updateParallel = function(selector, updates, callback) {\r\n      var self = this;\r\n      var done = _.after(updates.length, callback);\r\n\r\n      var next = function(err, affectedDocsNum) {\r\n        if (err) return callback(err);\r\n        done(null, affectedDocsNum);\r\n      };\r\n\r\n      _.each(updates, function(update) {\r\n        self.$$collection.update(selector, update, next);\r\n      });\r\n    };\r\n\r\n    AngularMeteorCollection.remove = function(keyOrDocs) {\r\n      var keys;\r\n\r\n      // remove whole collection\r\n      if (!keyOrDocs) {\r\n        keys = _.pluck(this, '_id');\r\n      }\r\n      // remove docs\r\n      else {\r\n        keyOrDocs = [].concat(keyOrDocs);\r\n\r\n        keys = _.map(keyOrDocs, function(keyOrDoc) {\r\n          return keyOrDoc._id || keyOrDoc;\r\n        });\r\n      }\r\n\r\n      // Checks if all keys are correct.\r\n      check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\r\n\r\n      var promises = keys.map(function(key) {\r\n        return this._removeDoc(key);\r\n      }, this);\r\n\r\n      return $meteorUtils.promiseAll(promises);\r\n    };\r\n\r\n    AngularMeteorCollection._removeDoc = function(id) {\r\n      var deferred = $q.defer();\r\n      var collection = this.$$collection;\r\n      var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\r\n      collection.remove(id, fulfill);\r\n      return deferred.promise;\r\n    };\r\n\r\n    AngularMeteorCollection._updateCursor = function(cursor, autoClientSave) {\r\n      var self = this;\r\n      // XXX - consider adding an option for a non-orderd result for faster performance\r\n      if (self._hObserve) self._stopObserving();\r\n\r\n\r\n      self._hObserve = cursor.observe({\r\n        addedAt: function(doc, atIndex) {\r\n          self.splice(atIndex, 0, doc);\r\n          self._serverBackup.splice(atIndex, 0, doc);\r\n          self._setServerUpdateMode();\r\n        },\r\n\r\n        changedAt: function(doc, oldDoc, atIndex) {\r\n          diffArray.deepCopyChanges(self[atIndex], doc);\r\n          diffArray.deepCopyRemovals(self[atIndex], doc);\r\n          self._serverBackup[atIndex] = self[atIndex];\r\n          self._setServerUpdateMode();\r\n        },\r\n\r\n        movedTo: function(doc, fromIndex, toIndex) {\r\n          self.splice(fromIndex, 1);\r\n          self.splice(toIndex, 0, doc);\r\n          self._serverBackup.splice(fromIndex, 1);\r\n          self._serverBackup.splice(toIndex, 0, doc);\r\n          self._setServerUpdateMode();\r\n        },\r\n\r\n        removedAt: function(oldDoc) {\r\n          var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\r\n\r\n          if (removedIndex != -1) {\r\n            self.splice(removedIndex, 1);\r\n            self._serverBackup.splice(removedIndex, 1);\r\n            self._setServerUpdateMode();\r\n          } else {\r\n            // If it's been removed on client then it's already not in collection\r\n            // itself but still is in the _serverBackup.\r\n            removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\r\n\r\n            if (removedIndex != -1) {\r\n              self._serverBackup.splice(removedIndex, 1);\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      self._hDataAutorun = Tracker.autorun(function() {\r\n        cursor.fetch();\r\n        if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\r\n      });\r\n    };\r\n\r\n    AngularMeteorCollection._stopObserving = function() {\r\n      this._hObserve.stop();\r\n      this._hDataAutorun.stop();\r\n      delete this._serverMode;\r\n      delete this._hUnsetTimeout;\r\n    };\r\n\r\n    AngularMeteorCollection._setServerUpdateMode = function(name) {\r\n      this._serverMode = true;\r\n      // To simplify server update logic, we don't follow\r\n      // updates from the client at the same time.\r\n      this._unsetAutoClientSave();\r\n    };\r\n\r\n    // Here we use $timeout to combine multiple updates that go\r\n    // each one after another.\r\n    AngularMeteorCollection._unsetServerUpdateMode = function(autoClientSave) {\r\n      var self = this;\r\n\r\n      if (self._hUnsetTimeout) {\r\n        $timeout.cancel(self._hUnsetTimeout);\r\n        self._hUnsetTimeout = null;\r\n      }\r\n\r\n      self._hUnsetTimeout = $timeout(function() {\r\n        self._serverMode = false;\r\n        // Finds updates that was potentially done from the client side\r\n        // and saves them.\r\n        var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\r\n        self._saveChanges(changes);\r\n        // After, continues following client updates.\r\n        if (autoClientSave) self._setAutoClientSave();\r\n      }, 0);\r\n    };\r\n\r\n    AngularMeteorCollection.stop = function() {\r\n      this._stopCursor();\r\n      this._hNewCurAutorun.stop();\r\n    };\r\n\r\n    AngularMeteorCollection._stopCursor = function() {\r\n      this._unsetAutoClientSave();\r\n\r\n      if (this._hObserve) {\r\n        this._hObserve.stop();\r\n        this._hDataAutorun.stop();\r\n      }\r\n\r\n      this.splice(0);\r\n      this._serverBackup.splice(0);\r\n    };\r\n\r\n    AngularMeteorCollection._unsetAutoClientSave = function(name) {\r\n      if (this._hRegAutoBind) {\r\n        this._hRegAutoBind();\r\n        this._hRegAutoBind = null;\r\n      }\r\n    };\r\n\r\n    AngularMeteorCollection._setAutoClientSave = function() {\r\n      var self = this;\r\n\r\n      // Always unsets auto save to keep only one $watch handler.\r\n      self._unsetAutoClientSave();\r\n\r\n      self._hRegAutoBind = $rootScope.$watch(function() {\r\n        return self;\r\n      }, function(nItems, oItems) {\r\n        if (nItems === oItems) return;\r\n\r\n        var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\r\n        self._unsetAutoClientSave();\r\n        self._saveChanges(changes);\r\n        self._setAutoClientSave();\r\n      }, true);\r\n    };\r\n\r\n    AngularMeteorCollection._saveChanges = function(changes) {\r\n      var self = this;\r\n\r\n      // Saves added documents\r\n      // Using reversed iteration to prevent indexes from changing during splice\r\n      var addedDocs = changes.added.reverse().map(function(descriptor) {\r\n        self.splice(descriptor.index, 1);\r\n        return descriptor.item;\r\n      });\r\n\r\n      if (addedDocs.length) self.save(addedDocs);\r\n\r\n      // Removes deleted documents\r\n      var removedDocs = changes.removed.map(function(descriptor) {\r\n        return descriptor.item;\r\n      });\r\n\r\n      if (removedDocs.length) self.remove(removedDocs);\r\n\r\n      // Updates changed documents\r\n      changes.changed.forEach(function(descriptor) {\r\n        self._updateDiff(descriptor.selector, descriptor.modifier);\r\n      });\r\n    };\r\n\r\n    return AngularMeteorCollection;\r\n}]);\r\n\r\nangularMeteorCollection.factory('$meteorCollectionFS', [\r\n  '$meteorCollection', 'diffArray', '$angularMeteorSettings',\r\n  function($meteorCollection, diffArray, $angularMeteorSettings) {\r\n    function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\r\n\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n      return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\r\n    }\r\n\r\n    return $meteorCollectionFS;\r\n}]);\r\n\r\nangularMeteorCollection.factory('$meteorCollection', [\r\n  'AngularMeteorCollection', '$rootScope', 'diffArray',\r\n  function(AngularMeteorCollection, $rootScope, diffArray) {\r\n    function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\r\n      // Validate parameters\r\n      if (!reactiveFunc) {\r\n        throw new TypeError('The first argument of $meteorCollection is undefined.');\r\n      }\r\n\r\n      if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\r\n        throw new TypeError(\r\n          'The first argument of $meteorCollection must be a function or ' +\r\n            'a have a find function property.');\r\n      }\r\n\r\n      if (!angular.isFunction(reactiveFunc)) {\r\n        collection = angular.isDefined(collection) ? collection : reactiveFunc;\r\n        reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\r\n      }\r\n\r\n      // By default auto save - true.\r\n      autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\r\n      diffFn = diffFn || diffArray;\r\n      return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\r\n    }\r\n\r\n    return $meteorCollection;\r\n}]);\r\n\r\nangularMeteorCollection.run([\r\n  '$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper',\r\n  function($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\r\n    var scopeProto = Object.getPrototypeOf($rootScope);\r\n    scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\r\n    scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-collection.js\n **/","/*global\r\n  angular, _, Mongo\r\n*/\r\n\r\n'use strict';\r\n\r\nvar angularMeteorObject = angular.module('angular-meteor.object',\r\n  ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray']);\r\n\r\nangularMeteorObject.factory('AngularMeteorObject', [\r\n  '$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings',\r\n  function($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\r\n\r\n    // A list of internals properties to not watch for, nor pass to the Document on update and etc.\r\n    AngularMeteorObject.$$internalProps = [\r\n      '$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope',\r\n      'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject',\r\n      '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'\r\n    ];\r\n\r\n    function AngularMeteorObject (collection, selector, options){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n      // Make data not be an object so we can extend it to preserve\r\n      // Collection Helpers and the like\r\n      var helpers = collection._helpers;\r\n      var data = _.isFunction(helpers) ? Object.create(helpers.prototype) : {};\r\n      var doc = collection.findOne(selector, options);\r\n      var collectionExtension = _.pick(AngularMeteorCollection, '_updateParallel');\r\n      _.extend(data, doc);\r\n      _.extend(data, AngularMeteorObject);\r\n      _.extend(data, collectionExtension);\r\n\r\n      // Omit options that may spoil document finding\r\n      data.$$options = _.omit(options, 'skip', 'limit');\r\n      data.$$collection = collection;\r\n      data.$$id = data._getId(selector);\r\n      data._serverBackup = doc || {};\r\n\r\n      return data;\r\n    }\r\n\r\n    AngularMeteorObject.getRawObject = function () {\r\n      return angular.copy(_.omit(this, this.$$internalProps));\r\n    };\r\n\r\n    AngularMeteorObject.subscribe = function () {\r\n      $meteorSubscribe.subscribe.apply(this, arguments);\r\n      return this;\r\n    };\r\n\r\n    AngularMeteorObject.save = function(custom) {\r\n      var deferred = $q.defer();\r\n      var collection = this.$$collection;\r\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\r\n      var oldDoc = collection.findOne(this.$$id);\r\n      var mods;\r\n\r\n      // update\r\n      if (oldDoc) {\r\n        if (custom)\r\n          mods = { $set: custom };\r\n        else {\r\n          mods = getUpdates(oldDoc, this.getRawObject());\r\n          // If there are no updates, there is nothing to do here, returning\r\n          if (_.isEmpty(mods)) {\r\n            return $q.when({ action: 'updated' });\r\n          }\r\n        }\r\n\r\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\r\n        this._updateDiff(mods, createFulfill({ action: 'updated' }));\r\n      }\r\n      // insert\r\n      else {\r\n        if (custom)\r\n          mods = _.clone(custom);\r\n        else\r\n          mods = this.getRawObject();\r\n\r\n        mods._id = mods._id || this.$$id;\r\n        collection.insert(mods, createFulfill({ action: 'inserted' }));\r\n      }\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    AngularMeteorObject._updateDiff = function(update, callback) {\r\n      var selector = this.$$id;\r\n      AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\r\n    };\r\n\r\n    AngularMeteorObject.reset = function(keepClientProps) {\r\n      var self = this;\r\n      var options = this.$$options;\r\n      var id = this.$$id;\r\n      var doc = this.$$collection.findOne(id, options);\r\n\r\n      if (doc) {\r\n        // extend SubObject\r\n        var docKeys = _.keys(doc);\r\n        var docExtension = _.pick(doc, docKeys);\r\n        var clientProps;\r\n\r\n        _.extend(self, docExtension);\r\n        _.extend(self._serverBackup, docExtension);\r\n\r\n        if (keepClientProps) {\r\n          clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\r\n        } else {\r\n          clientProps = _.keys(self);\r\n        }\r\n\r\n        var serverProps = _.keys(doc);\r\n        var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\r\n\r\n        removedKeys.forEach(function (prop) {\r\n          delete self[prop];\r\n          delete self._serverBackup[prop];\r\n        });\r\n      }\r\n\r\n      else {\r\n        _.keys(this.getRawObject()).forEach(function(prop) {\r\n          delete self[prop];\r\n        });\r\n\r\n        self._serverBackup = {};\r\n      }\r\n    };\r\n\r\n    AngularMeteorObject.stop = function () {\r\n      if (this.unregisterAutoDestroy)\r\n        this.unregisterAutoDestroy();\r\n\r\n      if (this.unregisterAutoBind)\r\n        this.unregisterAutoBind();\r\n\r\n      if (this.autorunComputation && this.autorunComputation.stop)\r\n        this.autorunComputation.stop();\r\n    };\r\n\r\n    AngularMeteorObject._getId = function(selector) {\r\n      var options = _.extend({}, this.$$options, {\r\n        fields: { _id: 1 },\r\n        reactive: false,\r\n        transform: null\r\n      });\r\n\r\n      var doc = this.$$collection.findOne(selector, options);\r\n\r\n      if (doc) return doc._id;\r\n      if (selector instanceof Mongo.ObjectID) return selector;\r\n      if (_.isString(selector)) return selector;\r\n      return new Mongo.ObjectID();\r\n    };\r\n\r\n    return AngularMeteorObject;\r\n}]);\r\n\r\n\r\nangularMeteorObject.factory('$meteorObject', [\r\n  '$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject',\r\n  function($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\r\n    function $meteorObject(collection, id, auto, options) {\r\n      // Validate parameters\r\n      if (!collection) {\r\n        throw new TypeError(\"The first argument of $meteorObject is undefined.\");\r\n      }\r\n\r\n      if (!angular.isFunction(collection.findOne)) {\r\n        throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\r\n      }\r\n\r\n      var data = new AngularMeteorObject(collection, id, options);\r\n      // Making auto default true - http://stackoverflow.com/a/15464208/1426570\r\n      data._auto = auto !== false;\r\n      _.extend(data, $meteorObject);\r\n      data._setAutos();\r\n      return data;\r\n    }\r\n\r\n    $meteorObject._setAutos = function() {\r\n      var self = this;\r\n\r\n      this.autorunComputation = $meteorUtils.autorun($rootScope, function() {\r\n        self.reset(true);\r\n      });\r\n\r\n      // Deep watches the model and performs autobind\r\n      this.unregisterAutoBind = this._auto && $rootScope.$watch(function(){\r\n        return self.getRawObject();\r\n      }, function (item, oldItem) {\r\n        if (item !== oldItem) self.save();\r\n      }, true);\r\n\r\n      this.unregisterAutoDestroy = $rootScope.$on('$destroy', function() {\r\n        if (self && self.stop) self.pop();\r\n      });\r\n    };\r\n\r\n    return $meteorObject;\r\n}]);\r\n\r\nangularMeteorObject.run([\r\n  '$rootScope', '$meteorObject', '$meteorStopper',\r\n  function ($rootScope, $meteorObject, $meteorStopper) {\r\n    var scopeProto = Object.getPrototypeOf($rootScope);\r\n    scopeProto.$meteorObject = $meteorStopper($meteorObject);\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-object.js\n **/","/*global\r\n angular, _, Package, Meteor\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorUser = angular.module('angular-meteor.user', [\r\n  'angular-meteor.utils',\r\n  'angular-meteor.core'\r\n]);\r\n\r\n// requires package 'accounts-password'\r\nangularMeteorUser.service('$meteorUser', [\r\n  '$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings',\r\n  function($rootScope, $meteorUtils, $q, $angularMeteorSettings){\r\n\r\n    var pack = Package['accounts-base'];\r\n    if (!pack) return;\r\n\r\n    var self = this;\r\n    var Accounts = pack.Accounts;\r\n\r\n    this.waitForUser = function(){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var deferred = $q.defer();\r\n\r\n      $meteorUtils.autorun($rootScope, function(){\r\n        if ( !Meteor.loggingIn() )\r\n          deferred.resolve( Meteor.user() );\r\n      }, true);\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    this.requireUser = function(){\r\n      if (!$angularMeteorSettings.suppressWarnings) {\r\n        console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n      }\r\n\r\n      var deferred = $q.defer();\r\n\r\n      $meteorUtils.autorun($rootScope, function(){\r\n        if ( !Meteor.loggingIn() ) {\r\n          if ( Meteor.user() === null)\r\n            deferred.reject(\"AUTH_REQUIRED\");\r\n          else\r\n            deferred.resolve( Meteor.user() );\r\n        }\r\n      }, true);\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    this.requireValidUser = function(validatorFn) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      return self.requireUser(true).then(function(user){\r\n        var valid = validatorFn( user );\r\n\r\n        if ( valid === true )\r\n          return user;\r\n        else if ( typeof valid === \"string\" )\r\n          return $q.reject( valid );\r\n        else\r\n          return $q.reject( \"FORBIDDEN\" );\r\n\t    });\r\n\t  };\r\n\r\n    this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\r\n    this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\r\n    this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\r\n    this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\r\n    this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\r\n    this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\r\n    this.logout = $meteorUtils.promissor(Meteor, 'logout');\r\n    this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\r\n    this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\r\n    this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\r\n    this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\r\n    this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\r\n    this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\r\n    this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\r\n    this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\r\n  }\r\n]);\r\n\r\nangularMeteorUser.run([\r\n  '$rootScope', '$angularMeteorSettings', '$$Core',\r\n  function($rootScope, $angularMeteorSettings, $$Core){\r\n\r\n    let ScopeProto = Object.getPrototypeOf($rootScope);\r\n    _.extend(ScopeProto, $$Core);\r\n\r\n    $rootScope.autorun(function(){\r\n      if (!Meteor.user) return;\r\n      $rootScope.currentUser = Meteor.user();\r\n      $rootScope.loggingIn = Meteor.loggingIn();\r\n    });\r\n  }\r\n]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-user.js\n **/","/*global\r\n angular, _, Meteor\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils']);\r\n\r\nangularMeteorMethods.service('$meteorMethods', [\r\n  '$q', '$meteorUtils', '$angularMeteorSettings',\r\n  function($q, $meteorUtils, $angularMeteorSettings) {\r\n    this.call = function(){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var deferred = $q.defer();\r\n      var fulfill = $meteorUtils.fulfill(deferred);\r\n      var args = _.toArray(arguments).concat(fulfill);\r\n      Meteor.call.apply(this, args);\r\n      return deferred.promise;\r\n    };\r\n  }\r\n]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-methods.js\n **/","/*global\r\n angular, Session\r\n */\r\n\r\n'use strict';\r\nvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils']);\r\n\r\nangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings',\r\n  function ($meteorUtils, $parse, $angularMeteorSettings) {\r\n    return function (session) {\r\n\r\n      return {\r\n\r\n        bind: function(scope, model) {\r\n          if (!$angularMeteorSettings.suppressWarnings)\r\n            console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n          var getter = $parse(model);\r\n          var setter = getter.assign;\r\n          $meteorUtils.autorun(scope, function() {\r\n            setter(scope, Session.get(session));\r\n          });\r\n\r\n          scope.$watch(model, function(newItem, oldItem) {\r\n            Session.set(session, getter(scope));\r\n          }, true);\r\n\r\n        }\r\n      };\r\n    };\r\n  }\r\n]);\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-session.js\n **/","/*global\r\n angular, Package\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils']);\r\n\r\n// requires package 'mdg:camera'\r\nangularMeteorCamera.service('$meteorCamera', [\r\n  '$q', '$meteorUtils', '$angularMeteorSettings',\r\n  function ($q, $meteorUtils, $angularMeteorSettings) {\r\n    if (!$angularMeteorSettings.suppressWarnings)\r\n      console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n    var pack = Package['mdg:camera'];\r\n    if (!pack) return;\r\n\r\n    var MeteorCamera = pack.MeteorCamera;\r\n\r\n    this.getPicture = function(options){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      options = options || {};\r\n      var deferred = $q.defer();\r\n      MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\r\n      return deferred.promise;\r\n    };\r\n  }\r\n]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-camera.js\n **/","angular.module('angular-meteor.utilities', [])\n\n/*\n  A utility service which is provided with general utility functions\n */\n.service('$$utils', [\n  '$rootScope',\n\n  function($rootScope) {\n    // Checks if an object is a cursor\n    this.isCursor = (obj) => {\n      return obj instanceof Meteor.Collection.Cursor;\n    };\n\n    // Cheecks if an object is a scope\n    this.isScope = (obj) => {\n      return obj instanceof $rootScope.constructor;\n    };\n\n    // Checks if two objects are siblings\n    this.areSiblings = (obj1, obj2) => {\n      return _.isObject(obj1) && _.isObject(obj2) &&\n        Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n    };\n\n    // Binds function into a scpecified context. If an object is provided, will bind every\n    // value in the object which is a function. If a tap function is provided, it will be\n    // called right after the function has been invoked.\n    this.bind = (fn, context, tap) => {\n      tap = _.isFunction(tap) ? tap : angular.noop;\n      if (_.isFunction(fn)) return bindFn(fn, context, tap);\n      if (_.isObject(fn)) return bindObj(fn, context, tap);\n      return fn;\n    };\n\n    const bindFn = (fn, context, tap) => {\n      return (...args) => {\n        const result = fn.apply(context, args);\n        tap.call(context, {\n          result,\n          args\n        });\n        return result;\n      };\n    };\n\n    const bindObj = (obj, context, tap) => {\n      return _.keys(obj).reduce((bound, k) => {\n        bound[k] = this.bind(obj[k], context, tap);\n        return bound;\n      }, {});\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/utils.js\n **/","angular.module('angular-meteor.mixer', [])\n\n/*\n  A service which lets us apply mixins into the `ChildScope` prototype.\n  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n  and any time a `ChildScope` prototype is created\n  it will be extended by the `$Mixer`.\n  This concept is good because it keeps our code\n  clean and simple, and easy to extend.\n  So any time we would like to define a new behaviour to our scope,\n  we will just use the `$Mixer` service.\n */\n.service('$Mixer', function() {\n  this._mixins = [];\n\n  // Adds a new mixin\n  this.mixin = (mixin) => {\n    if (!_.isObject(mixin)) {\n      throw Error('argument 1 must be an object');\n    }\n\n    this._mixins = _.union(this._mixins, [mixin]);\n    return this;\n  };\n\n  // Removes a mixin. Useful mainly for test purposes\n  this._mixout = (mixin) => {\n    this._mixins = _.without(this._mixins, mixin);\n    return this;\n  };\n\n  // Invoke function mixins with the provided context and arguments\n  this._construct = (context, ...args) => {\n    this._mixins.filter(_.isFunction).forEach((mixin) => {\n      mixin.call(context, ...args);\n    });\n\n    return context;\n  };\n\n  // Extend prototype with the defined mixins\n  this._extend = (obj) => {\n    return _.extend(obj, ...this._mixins);\n  };\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/mixer.js\n **/","import './mixer';\n\nangular.module('angular-meteor.scope', [\n  'angular-meteor.mixer'\n])\n\n\n.run([\n  '$rootScope',\n  '$Mixer',\n\n  function($rootScope, $Mixer) {\n    const Scope = $rootScope.constructor;\n    const $new = $rootScope.$new;\n\n    // Extends and constructs every newly created scope without affecting the root scope\n    Scope.prototype.$new = function(isolate, parent) {\n      const firstChild = this === $rootScope && !this.$$ChildScope;\n      const scope = $new.call(this, isolate, parent);\n\n      // If the scope is isolated we would like to extend it aswell\n      if (isolate) {\n        // The scope is the prototype of its upcomming child scopes, so the methods would\n        // be accessable to them as well\n        $Mixer._extend(scope);\n      }\n      // Else, if this is the first child of the root scope we would like to apply the extensions\n      // without affection the root scope\n      else if (firstChild) {\n        // Creating a middle layer where all the extensions are gonna be applied to\n        scope.__proto__ = this.$$ChildScope.prototype =\n          $Mixer._extend(Object.create(this));\n      }\n\n      return $Mixer._construct(scope);\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/scope.js\n **/","import './utils';\nimport './mixer';\n\nangular.module('angular-meteor.core', [\n  'angular-meteor.utilities',\n  'angular-meteor.mixer'\n])\n\n\n/*\n  A mixin which provides us with core Meteor functions.\n */\n.factory('$$Core', [\n  '$q',\n  '$$utils',\n\n  function($q, $$utils) {\n    function $$Core() {}\n\n    // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n    $$Core.autorun = function(fn, options = {}) {\n      fn = this.$bindToContext(fn);\n\n      if (!_.isFunction(fn)) {\n        throw Error('argument 1 must be a function');\n      }\n      if (!_.isObject(options)) {\n        throw Error('argument 2 must be an object');\n      }\n\n      const computation = Tracker.autorun(fn, options);\n      this.$$autoStop(computation);\n      return computation;\n    };\n\n    // Calls Meteor.subscribe() which will be digested after each invokation\n    // and automatically destroyed\n    $$Core.subscribe = function(name, fn, cb) {\n      fn = this.$bindToContext(fn || angular.noop);\n      cb = cb ? this.$bindToContext(cb) : angular.noop;\n\n      if (!_.isString(name)) {\n        throw Error('argument 1 must be a string');\n      }\n      if (!_.isFunction(fn)) {\n        throw Error('argument 2 must be a function');\n      }\n      if (!_.isFunction(cb) && !_.isObject(cb)) {\n        throw Error('argument 3 must be a function or an object');\n      }\n\n      const result = {};\n\n      const computation = this.autorun(() => {\n        let args = fn();\n        if (angular.isUndefined(args)) args = [];\n\n        if (!_.isArray(args)) {\n          throw Error(`reactive function's return value must be an array`);\n        }\n\n        const subscription = Meteor.subscribe(name, ...args, cb);\n        result.ready = subscription.ready.bind(subscription);\n        result.subscriptionId = subscription.subscriptionId;\n      });\n\n      // Once the computation has been stopped,\n      // any subscriptions made inside will be stopped as well\n      result.stop = computation.stop.bind(computation);\n      return result;\n    };\n\n    // Calls Meteor.call() wrapped by a digestion cycle\n    $$Core.callMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n      return Meteor.call(...args, fn);\n    };\n\n    // Calls Meteor.apply() wrapped by a digestion cycle\n    $$Core.applyMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n      return Meteor.apply(...args, fn);\n    };\n\n    $$Core.$$autoStop = function(stoppable) {\n      this.$on('$destroy', stoppable.stop.bind(stoppable));\n    };\n\n    // Digests scope only if there is no phase at the moment\n    $$Core.$$throttledDigest = function() {\n      const isDigestable = !this.$$destroyed &&\n        !this.$$phase &&\n        !this.$root.$$phase;\n\n      if (isDigestable) this.$digest();\n    };\n\n    // Creates a promise only that the digestion cycle will be called at its fulfillment\n    $$Core.$$defer = function() {\n      const deferred = $q.defer();\n      // Once promise has been fulfilled, digest\n      deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n      return deferred;\n    };\n\n    // Binds an object or a function to the scope to the view model and digest it once it is invoked\n    $$Core.$bindToContext = function(fn) {\n      return $$utils.bind(fn, this, this.$$throttledDigest.bind(this));\n    };\n\n    return $$Core;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/core.js\n **/","import './utils';\nimport './mixer';\nimport './core';\n\nangular.module('angular-meteor.view-model', [\n  'angular-meteor.utilities',\n  'angular-meteor.mixer',\n  'angular-meteor.core'\n])\n\n/*\n  A mixin which lets us bind a view model into a scope.\n  Note that only a single view model can be bound,\n  otherwise the scope might behave unexpectedly.\n  Mainly used to define the controller as the view model,\n  and very useful when wanting to use Angular's `controllerAs` syntax.\n */\n.factory('$$ViewModel', [\n  '$$utils',\n  '$Mixer',\n\n  function($$utils, $Mixer) {\n    function $$ViewModel(vm = this) {\n      // Defines the view model on the scope.\n      this.$$vm = vm;\n    }\n\n    // Gets an object, wraps it with scope functions and returns it\n    $$ViewModel.viewModel = function(vm) {\n      if (!_.isObject(vm)) {\n        throw Error('argument 1 must be an object');\n      }\n\n      // Apply mixin functions\n      $Mixer._mixins.forEach((mixin) => {\n        // Reject methods which starts with double $\n        const keys = _.keys(mixin).filter(k => k.match(/^(?!\\$\\$).*$/));\n        const proto = _.pick(mixin, keys);\n        // Bind all the methods to the prototype\n        const boundProto = $$utils.bind(proto, this);\n        // Add the methods to the view model\n        _.extend(vm, boundProto);\n      });\n\n      // Apply mixin constructors on the view model\n      $Mixer._construct(this, vm);\n      return vm;\n    };\n\n    // Override $$Core.$bindToContext to be bound to view model instead of scope\n    $$ViewModel.$bindToContext = function(fn) {\n      return $$utils.bind(fn, this.$$vm, this.$$throttledDigest.bind(this));\n    };\n\n    return $$ViewModel;\n  }\n])\n\n\n/*\n  Illustrates the old API where a view model is created using $reactive service\n */\n.service('$reactive', [\n  '$$utils',\n\n  function($$utils) {\n    class Reactive {\n      constructor(vm) {\n        if (!_.isObject(vm)) {\n          throw Error('argument 1 must be an object');\n        }\n\n        _.defer(() => {\n          if (!this._attached) {\n            console.warn('view model was not attached to any scope');\n          }\n        });\n\n        this._vm = vm;\n      }\n\n      attach(scope) {\n        this._attached = true;\n\n        if (!$$utils.isScope(scope)) {\n          throw Error('argument 1 must be a scope');\n        }\n\n        const viewModel = scope.viewModel(this._vm);\n\n        // Similar to the old/Meteor API\n        viewModel.call = viewModel.callMethod;\n        viewModel.apply = viewModel.applyMethod;\n\n        return viewModel;\n      }\n    }\n\n    return (vm) => new Reactive(vm);\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/view-model.js\n **/","import './utils';\nimport './mixer';\nimport './core';\nimport './view-model';\n\nangular.module('angular-meteor.reactive', [\n  'angular-meteor.utilities',\n  'angular-meteor.mixer',\n  'angular-meteor.core',\n  'angular-meteor.view-model'\n])\n\n\n/*\n  A mixin which enhance our reactive abilities by providing methods that are capable of updating\n  our scope reactively.\n */\n.factory('$$Reactive', [\n  '$parse',\n  '$$utils',\n  '$angularMeteorSettings',\n\n  function($parse, $$utils, $angularMeteorSettings) {\n    function $$Reactive(vm = this) {\n      // Helps us track changes made in the view model\n      vm.$$dependencies = {};\n    }\n\n    // Gets an object containing functions and define their results as reactive properties.\n    // Once a return value has been changed the property will be reset.\n    $$Reactive.helpers = function(props = {}) {\n      if (!_.isObject(props)) {\n        throw Error('argument 1 must be an object');\n      }\n\n      _.each(props, (v, k, i) => {\n        if (!_.isFunction(v)) {\n          throw Error(`helper ${i + 1} must be a function`);\n        }\n\n        if (!this.$$vm.$$dependencies[k]) {\n        // Registers a new dependency to the specified helper\n          this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n        }\n\n        this.$$setFnHelper(k, v);\n      });\n    };\n\n    // Gets a model reactively\n    $$Reactive.getReactively = function(k, isDeep = false) {\n      if (!_.isBoolean(isDeep)) {\n        throw Error('argument 2 must be a boolean');\n      }\n\n      return this.$$reactivateEntity(k, this.$watch, isDeep);\n    };\n\n    // Gets a collection reactively\n    $$Reactive.getCollectionReactively = function(k) {\n      return this.$$reactivateEntity(k, this.$watchCollection);\n    };\n\n    // Gets an entity reactively, and once it has been changed the computation will be recomputed\n    $$Reactive.$$reactivateEntity = function(k, watcher, ...watcherArgs) {\n      if (!_.isString(k)) {\n        throw Error('argument 1 must be a string');\n      }\n\n      if (!this.$$vm.$$dependencies[k]) {\n        this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n        this.$$watchEntity(k, watcher, ...watcherArgs);\n      }\n\n      this.$$vm.$$dependencies[k].depend();\n      return $parse(k)(this.$$vm);\n    };\n\n    // Watches for changes in the view model, and if so will notify a change\n    $$Reactive.$$watchEntity = function(k, watcher, ...watcherArgs) {\n      // Gets a deep property from the view model\n      const getVal = _.partial($parse(k), this.$$vm);\n      const initialVal = getVal();\n\n      // Watches for changes in the view model\n      watcher.call(this, getVal, (val, oldVal) => {\n        const hasChanged =\n          val !== initialVal ||\n          val !== oldVal;\n\n        // Notify if a change has been detected\n        if (hasChanged) this.$$changed(k);\n      }, ...watcherArgs);\n    };\n\n    // Invokes a function and sets the return value as a property\n    $$Reactive.$$setFnHelper = function(k, fn) {\n      this.autorun((computation) => {\n        // Invokes the reactive functon\n        const model = fn.apply(this.$$vm);\n\n        // Ignore notifications made by the following handler\n        Tracker.nonreactive(() => {\n          // If a cursor, observe its changes and update acoordingly\n          if ($$utils.isCursor(model)) {\n            const observation = this.$$handleCursor(k, model);\n\n            computation.onInvalidate(() => {\n              observation.stop();\n              this.$$vm[k].splice(0);\n            });\n          } else {\n            this.$$handleNonCursor(k, model);\n          }\n\n          // Notify change and update the view model\n          this.$$changed(k);\n        });\n      });\n    };\n\n    // Sets a value helper as a setter and a getter which will notify computations once used\n    $$Reactive.$$setValHelper = function(k, v, watch = true) {\n      // If set, reactives property\n      if (watch) {\n        const isDeep = _.isObject(v);\n        this.getReactively(k, isDeep);\n      }\n\n      Object.defineProperty(this.$$vm, k, {\n        configurable: true,\n        enumerable: true,\n\n        get: () => {\n          return v;\n        },\n        set: (newVal) => {\n          v = newVal;\n          this.$$changed(k);\n        }\n      });\n    };\n\n    // Fetching a cursor and updates properties once the result set has been changed\n    $$Reactive.$$handleCursor = function(k, cursor) {\n      // If not defined set it\n      if (angular.isUndefined(this.$$vm[k])) {\n        this.$$setValHelper(k, cursor.fetch(), false);\n      }\n      // If defined update it\n      else {\n        const diff = jsondiffpatch.diff(this.$$vm[k], cursor.fetch());\n        jsondiffpatch.patch(this.$$vm[k], diff);\n      }\n\n      // Observe changes made in the result set\n      const observation = cursor.observe({\n        addedAt: (doc, atIndex) => {\n          if (!observation) return;\n          this.$$vm[k].splice(atIndex, 0, doc);\n          this.$$changed(k);\n        },\n        changedAt: (doc, oldDoc, atIndex) => {\n          const diff = jsondiffpatch.diff(this.$$vm[k][atIndex], doc);\n          jsondiffpatch.patch(this.$$vm[k][atIndex], diff);\n          this.$$changed(k);\n        },\n        movedTo: (doc, fromIndex, toIndex) => {\n          this.$$vm[k].splice(fromIndex, 1);\n          this.$$vm[k].splice(toIndex, 0, doc);\n          this.$$changed(k);\n        },\n        removedAt: (oldDoc, atIndex) => {\n          this.$$vm[k].splice(atIndex, 1);\n          this.$$changed(k);\n        }\n      });\n\n      return observation;\n    };\n\n    $$Reactive.$$handleNonCursor = function(k, data) {\n      let v = this.$$vm[k];\n\n      if (angular.isDefined(v)) {\n        delete this.$$vm[k];\n        v = null;\n      }\n\n      if (angular.isUndefined(v)) {\n        this.$$setValHelper(k, data);\n      }\n      // Update property if the new value is from the same type\n      else if ($$utils.areSiblings(v, data)) {\n        const diff = jsondiffpatch.diff(v, data);\n        jsondiffpatch.patch(v, diff);\n        this.$$changed(k);\n      } else {\n        this.$$vm[k] = data;\n      }\n    };\n\n    // Notifies dependency in view model\n    $$Reactive.$$depend = function(k) {\n      this.$$vm.$$dependencies[k].depend();\n    };\n\n    // Notifies change in view model\n    $$Reactive.$$changed = function(k) {\n      this.$$throttledDigest();\n      this.$$vm.$$dependencies[k].changed();\n    };\n\n    return $$Reactive;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/reactive.js\n **/"],"sourceRoot":""}